diff --git a/.mailmap b/.mailmap
index d6405683..cdacea39 100644
--- a/.mailmap
+++ b/.mailmap
@@ -1,4 +1,5 @@
-Alejandro Colomar <alx@nginx.com> <a.colomar@f5.com>
-Alejandro Colomar <alx@nginx.com> <alx.manpages@gmail.com>
+Alejandro Colomar <alx@kernel.org> <alx@nginx.com>
+Alejandro Colomar <alx@kernel.org> <a.colomar@f5.com>
+Alejandro Colomar <alx@kernel.org> <alx.manpages@gmail.com>
 Andrew Clayton <a.clayton@nginx.com> <andrew@digital-domain.net>
 Andrew Clayton <a.clayton@nginx.com> <a.clayton@f5.com>
diff --git a/WASM-WASI-HTTP-README.md b/WASM-WASI-HTTP-README.md
new file mode 100644
index 00000000..c3bcda99
--- /dev/null
+++ b/WASM-WASI-HTTP-README.md
@@ -0,0 +1,152 @@
+# Wasmtime Unit Module
+
+This directory contains a sample implementation of using Wasmtime to implement a
+Unit module which can be loaded into `unitd`. This uses a language module type
+of `wasm-wasi-http`.
+
+* The specified `component` is expected to adhere to [`wasi:http/proxy`
+  world][proxy].
+
+* Each request instantiates a new component. Previously a single instance was
+  used for all requests, and instead a new instance is created per-request now.
+  This means that state cannot be leaked between requests since sandboxes are
+  entirely destroyed between requests.
+
+* Previously configured functions about allocation and hooks are no longer read
+  and/or processed. The runtime is guided by the implementation of the `proxy`
+  world instead.
+
+* No custom host APIs are provided, instead only those in the `proxy` world are
+  available. This means that components must only use WASI base functions and
+  some `wasi:http` functions.
+
+[proxy]: https://github.com/WebAssembly/wasi-http/blob/8aa75f58a6c0c5819ae898ba911753a43660e4a7/wit/proxy.wit#L7-L34
+
+## Building
+
+The sample implementation here is written in Rust. Communication with UNIT is
+done via FFI. First the UNIT server must be compiled:
+
+```
+./configure ...
+make
+```
+
+Now you can simply
+
+```
+./configure wasm-wasi-http
+make install
+```
+
+### Under the covers
+
+This is what the above `configure` does...
+
+Next Rust bindings will use the `nxt_unit.c` file so that object must built:
+
+```
+make build/src/nxt_unit.o
+```
+
+Next the Rust bindings can be built with
+
+```
+cargo build --release --manifest-path src/wasm-wasi-http/Cargo.toml
+```
+
+This will use [`bindgen`](https://crates.io/crates/bindgen) to create
+auto-generated FFI bindings between UNIT and Rust. This ensures that if header
+files in UNIT change then Rust code will fail to compile if not updated.
+
+The output of compilation is located at
+`src/wasm-wasi-http/target/release/libnxt_wasmtime.so`. This file can then be
+placed in
+`$UNIT_LIBDIR/unit/modules/wasmtime.unit.so`.
+
+## Example Project
+
+> **Note**: This walks through some manual steps for Rust to show what's going
+> on, but if you're actually using Rust you'll probably use [`cargo
+> component`](https://github.com/bytecodealliance/cargo-component/)
+
+An example component is located in the `src/wasm-wasi-http/example` directory
+with the bulk of the source code living in
+`src/wasm-wasi-http/example/src/lib.rs`. Building this example can be done
+with:
+
+```
+cargo build --target wasm32-wasi --release --manifest-path wasm-wasi-http-example/Cargo.toml
+```
+
+The output core wasm module is located at
+`wasm-wasi-http-example/target/wasm32-wasi/release/example.wasm`. Note that
+the Wasmtime module above takes components as an input, however. To create a
+component first install the
+[`wasm-tools`](https://github.com/bytecodealliance/wasm-tools) repository.
+Next create the component with:
+
+```
+wasm-tools component new \
+  wasm-wasi-http-example/target/wasm32-wasi/release/example.wasm \
+  --adapt ./wasm-wasi-http-example/wasi_snapshot_preview1.reactor.wasm \
+  -o wasm-wasi-http-example/target/wasm32-wasi/release/example.component.wasm
+```
+
+This will create a component at
+`wasm-wasi-http-example/target/wasm32-wasi/release/example.component.wasm`.
+This can then be configured as:
+
+```
+curl -X PUT --data-binary '{
+      "listeners": {
+          "127.0.0.1:8080": {
+              "pass": "applications/wasm"
+          }
+      },
+
+      "applications": {
+          "wasm": {
+              "type": "wasm-wasi-http",
+              "component": "/path/to/example.component.wasm"
+          }
+      }
+  }' --unix-socket $HOME/unit/var/run/unit/control.unit.sock http://localhost/config/
+```
+
+Next you can curl with:
+
+```
+$ curl -v http://localhost:8080/hello\?a\=b -d 'xyzabcd'
+ * Welcome to the component model in Rust! *
+
+[Request Info]
+REQUEST_PATH = /hello?a=b
+METHOD = POST
+SCHEME = http
+AUTHORITY = localhost
+
+[Request Headers]
+host = localhost:8080
+user-agent = curl/7.81.0
+accept = */*
+content-length = 7
+content-type = application/x-www-form-urlencoded
+
+[Request Data]
+xyzabcd
+```
+
+## Running the same component in Wasmtime
+
+As an example, the same component can be executed in Wasmtime:
+
+```
+$ wasmtime serve wasm-wasi-http-example/target/wasm32-wasi/release/example.component.wasm
+```
+
+```
+$ curl http://localhost:8080/hello\?a\=b -d 'xyzabcd'
+<same as above>
+```
+```
diff --git a/WASM-WASI-HTTP-TODO.md b/WASM-WASI-HTTP-TODO.md
new file mode 100644
index 00000000..bef05939
--- /dev/null
+++ b/WASM-WASI-HTTP-TODO.md
@@ -0,0 +1,11 @@
+# Todo List Before Actual Merging
+
+- Fix/add missing features, e.g request-streaming.
+- Decide on where code should actually live.
+- rustfmt(1) code to 80 chars (assuming we want to match C).
+- Where should the examples go?
+- ... on a related note, what about
+  wasmtime/example/wasi\_snapshot\_preview1.reactor.wasm should this live in
+  the repository or be acquired from upstream? A similar question could
+  perhaps be asked about the wit files.
+- Integrate with the build system.
diff --git a/auto/help b/auto/help
index b6d9919f..188692a0 100644
--- a/auto/help
+++ b/auto/help
@@ -79,4 +79,9 @@ cat << END
   wasm OPTIONS	       configure WebAssembly module
 		       run "./configure wasm --help" to see available options
 
+  wasm-wasi-http OPTIONS
+		       configure WebAssembly wasi-http module
+		       run "./configure wasm-wasi-http --help" to see
+		       available options
+
 END
diff --git a/auto/modules/conf b/auto/modules/conf
index 31be751f..6909b4f6 100644
--- a/auto/modules/conf
+++ b/auto/modules/conf
@@ -37,6 +37,10 @@ case "$nxt_module" in
        . auto/modules/wasm
    ;;
 
+   wasm-wasi-http)
+       . auto/modules/wasm-wasi-http
+   ;;
+
    *)
        echo
        echo $0: error: invalid module \"$nxt_module\".
diff --git a/auto/modules/wasm-wasi-http b/auto/modules/wasm-wasi-http
new file mode 100644
index 00000000..5a57f697
--- /dev/null
+++ b/auto/modules/wasm-wasi-http
@@ -0,0 +1,119 @@
+# Copyright (C) Andrew Clayton
+# Copyright (C) F5, Inc.
+
+
+NXT_WWH_MODULE=wasm-wasi-http
+NXT_WWH_MOD_NAME=`echo $NXT_WWH_MODULE | tr '-' '_'`.unit.so
+
+
+shift
+
+for nxt_option; do
+
+    case "$nxt_option" in
+        -*=*) value=`echo "$nxt_option" | sed -e 's/[-_a-zA-Z0-9]*=//'`     ;;
+           *) value="" ;;
+    esac
+
+    case "$nxt_option" in
+
+        --help)
+            cat << END
+
+END
+            exit 0
+        ;;
+
+        *)
+            echo
+            echo $0: error: invalid wasm option \"$nxt_option\"
+            echo
+            exit 1
+        ;;
+    esac
+
+done
+
+
+if [ ! -f $NXT_AUTOCONF_DATA ]; then
+   echo
+   echo Please run common $0 before configuring module \"$nxt_module\".
+   echo
+   exit 1
+fi
+
+. $NXT_AUTOCONF_DATA
+
+NXT_WWH_WASM_TOOLS_BIN=${NXT_WWH_WASM_TOOLS_BIN=}
+
+
+$echo "configuring $NXT_WWH_MODULE module"
+$echo "configuring $NXT_WWH_MODULE module ..." >> $NXT_AUTOCONF_ERR
+
+$echo -n "looking for rust compiler ... "
+
+if [ -z `which rustc 2>/dev/null` ]; then
+    $echo "not found."
+    exit 1;
+fi
+
+$echo "found."
+
+$echo -n "looking for cargo ... "
+
+if [ -z `which cargo 2>/dev/null` ]; then
+    $echo "not found."
+    exit 1;
+fi
+
+$echo "found."
+
+
+if grep ^$NXT_WWH_MODULE: $NXT_MAKEFILE 2>&1 > /dev/null; then
+    $echo
+    $echo $0: error: duplicate \"$NXT_WWH_MODULE\" module configured.
+    $echo
+    exit 1;
+fi
+
+
+$echo " + $NXT_WWH_MODULE module: $NXT_WWH_MOD_NAME"
+
+
+NXT_OS=$(uname -o)
+
+if [ $NXT_OS = "Darwin" ]; then
+	NXT_CARGO_CMD="cargo rustc --release --manifest-path src/wasm-wasi-http/Cargo.toml -- --emit link=target/release/libnxt_wasmtime.so -C link-args='-undefined dynamic_lookup'"
+else
+	NXT_CARGO_CMD="cargo build --release --manifest-path src/wasm-wasi-http/Cargo.toml"
+fi
+
+
+cat << END >> $NXT_MAKEFILE
+
+.PHONY: ${NXT_WWH_MODULE}
+.PHONY: ${NXT_WWH_MODULE}-install
+.PHONY: ${NXT_WWH_MODULE}-uninstall
+
+all: ${NXT_WWH_MODULE}
+
+${NXT_WWH_MODULE}:  $NXT_BUILD_DIR/lib/unit/modules/$NXT_WWH_MOD_NAME
+
+$NXT_BUILD_DIR/lib/unit/modules/$NXT_WWH_MOD_NAME:
+	make build/src/nxt_unit.o
+	$NXT_CARGO_CMD
+
+install: ${NXT_WWH_MODULE}-install
+
+${NXT_WWH_MODULE}-install: ${NXT_WWH_MODULE} install-check
+	install -d \$(DESTDIR)$NXT_MODULESDIR
+	install -p src/wasm-wasi-http/target/release/libnxt_wasmtime.so \\
+		\$(DESTDIR)$NXT_MODULESDIR/$NXT_WWH_MOD_NAME
+
+uninstall: ${NXT_WWH_MODULE}-uninstall
+
+${NXT_WWH_MODULE}-uninstall:
+	rm -f \$(DESTDIR)$NXT_MODULESDIR/$NXT_WWH_MOD_NAME
+	@rmdir -p \$(DESTDIR)$NXT_MODULESDIR 2>/dev/null || true
+
+END
diff --git a/pkg/docker/Dockerfile.wasmtime b/pkg/docker/Dockerfile.wasmtime
new file mode 100644
index 00000000..b045a867
--- /dev/null
+++ b/pkg/docker/Dockerfile.wasmtime
@@ -0,0 +1,104 @@
+FROM debian:bullseye-slim
+
+LABEL org.opencontainers.image.title="Unit Preview (wasm-wasi-http)"
+LABEL org.opencontainers.image.description="Official preview build of Unit for Docker."
+LABEL org.opencontainers.image.url="https://unit.nginx.org"
+LABEL org.opencontainers.image.source="https://github.com/nginx/unit"
+LABEL org.opencontainers.image.documentation="https://unit.nginx.org/installation/#docker-images"
+LABEL org.opencontainers.image.vendor="NGINX Docker Maintainers <docker-maint@nginx.com>"
+LABEL org.opencontainers.image.version="1.31.1"
+
+RUN set -ex \
+    && savedAptMark="$(apt-mark showmanual)" \
+    && apt-get update \
+    && apt-get install --no-install-recommends --no-install-suggests -y ca-certificates git build-essential libssl-dev libpcre2-dev curl pkg-config libclang-dev \
+    && mkdir -p /usr/lib/unit/modules /usr/lib/unit/debug-modules \
+    && mkdir -p /usr/src/unit \
+    && cd /usr/src/unit \
+    && git clone https://github.com/ac000/unit --branch wasm-wasi-http \
+    && cd unit \
+    && NCPU="$(getconf _NPROCESSORS_ONLN)" \
+    && DEB_HOST_MULTIARCH="$(dpkg-architecture -q DEB_HOST_MULTIARCH)" \
+    && CC_OPT="$(DEB_BUILD_MAINT_OPTIONS="hardening=+all,-pie" DEB_CFLAGS_MAINT_APPEND="-Wp,-D_FORTIFY_SOURCE=2 -fPIC" dpkg-buildflags --get CFLAGS)" \
+    && LD_OPT="$(DEB_BUILD_MAINT_OPTIONS="hardening=+all,-pie" DEB_LDFLAGS_MAINT_APPEND="-Wl,--as-needed -pie" dpkg-buildflags --get LDFLAGS)" \
+    && CONFIGURE_ARGS_MODULES="--prefix=/usr \
+                --statedir=/var/lib/unit \
+                --control=unix:/var/run/control.unit.sock \
+                --runstatedir=/var/run \
+                --pid=/var/run/unit.pid \
+                --logdir=/var/log \
+                --log=/var/log/unit.log \
+                --tmpdir=/var/tmp \
+                --user=unit \
+                --group=unit \
+                --openssl \
+                --libdir=/usr/lib/$DEB_HOST_MULTIARCH" \
+    && CONFIGURE_ARGS="$CONFIGURE_ARGS_MODULES \
+                --njs" \
+    && make -j $NCPU -C pkg/contrib .njs \
+    && export PKG_CONFIG_PATH=$(pwd)/pkg/contrib/njs/build \
+    && ./configure $CONFIGURE_ARGS --cc-opt="$CC_OPT" --ld-opt="$LD_OPT" --modulesdir=/usr/lib/unit/debug-modules --debug \
+    && make -j $NCPU unitd \
+    && install -pm755 build/sbin/unitd /usr/sbin/unitd-debug \
+    && make clean \
+    && ./configure $CONFIGURE_ARGS --cc-opt="$CC_OPT" --ld-opt="$LD_OPT" --modulesdir=/usr/lib/unit/modules \
+    && make -j $NCPU unitd \
+    && install -pm755 build/sbin/unitd /usr/sbin/unitd \
+    && make clean \
+    && export RUST_VERSION=1.71.0 \
+    && export RUSTUP_HOME=/usr/src/unit/rustup \
+    && export CARGO_HOME=/usr/src/unit/cargo \
+    && export PATH=/usr/src/unit/cargo/bin:$PATH \
+    && dpkgArch="$(dpkg --print-architecture)" \
+    && case "${dpkgArch##*-}" in \
+       amd64) rustArch="x86_64-unknown-linux-gnu"; rustupSha256="0b2f6c8f85a3d02fde2efc0ced4657869d73fccfce59defb4e8d29233116e6db" ;; \
+       arm64) rustArch="aarch64-unknown-linux-gnu"; rustupSha256="673e336c81c65e6b16dcdede33f4cc9ed0f08bde1dbe7a935f113605292dc800" ;; \
+       *) echo >&2 "unsupported architecture: ${dpkgArch}"; exit 1 ;; \
+    esac \
+    && url="https://static.rust-lang.org/rustup/archive/1.26.0/${rustArch}/rustup-init" \
+    && curl -L -O "$url" \
+    && echo "${rustupSha256} *rustup-init" | sha256sum -c - \
+    && chmod +x rustup-init \
+    && ./rustup-init -y --no-modify-path --profile minimal --default-toolchain $RUST_VERSION --default-host ${rustArch} \
+    && rm rustup-init \
+    && rustup --version \
+    && cargo --version \
+    && rustc --version \
+    && ./configure $CONFIGURE_ARGS_MODULES --cc-opt="$CC_OPT" --modulesdir=/usr/lib/unit/modules \
+    && make build/src/nxt_unit.o \
+    && cargo build --release --manifest-path src/wasm-wasi-http/Cargo.toml \
+    && install -pm755 src/wasm-wasi-http/target/release/libnxt_wasmtime.so /usr/lib/unit/modules/wasmtime.unit.so \
+    && rm -rf src/wasm-wasi-http/target \
+    && rm -rf /usr/src/unit \
+    && for f in /usr/sbin/unitd /usr/lib/unit/modules/*.unit.so; do \
+        ldd $f | awk '/=>/{print $(NF-1)}' | while read n; do dpkg-query -S $n; done | sed 's/^\([^:]\+\):.*$/\1/' | sort | uniq >> /requirements.apt; \
+       done \
+    && apt-mark showmanual | xargs apt-mark auto > /dev/null \
+    && { [ -z "$savedAptMark" ] || apt-mark manual $savedAptMark; } \
+    && /bin/true \
+    && mkdir -p /var/lib/unit/ \
+    && mkdir -p /docker-entrypoint.d/ \
+    && groupadd --gid 999 unit \
+    && useradd \
+         --uid 999 \
+         --gid unit \
+         --no-create-home \
+         --home /nonexistent \
+         --comment "unit user" \
+         --shell /bin/false \
+         unit \
+    && apt-get update \
+    && apt-get --no-install-recommends --no-install-suggests -y install curl $(cat /requirements.apt) \
+    && apt-get purge -y --auto-remove build-essential \
+    && rm -rf /var/lib/apt/lists/* \
+    && rm -f /requirements.apt \
+    && ln -sf /dev/stdout /var/log/unit.log
+
+COPY docker-entrypoint.sh /usr/local/bin/
+COPY welcome.* /usr/share/unit/welcome/
+
+STOPSIGNAL SIGTERM
+
+ENTRYPOINT ["/usr/local/bin/docker-entrypoint.sh"]
+EXPOSE 80
+CMD ["unitd", "--no-daemon", "--control", "unix:/var/run/control.unit.sock"]
diff --git a/src/nxt_application.c b/src/nxt_application.c
index 872e387a..b6e1b45d 100644
--- a/src/nxt_application.c
+++ b/src/nxt_application.c
@@ -1100,6 +1100,9 @@ nxt_app_parse_type(u_char *p, size_t length)
     } else if (nxt_str_eq(&str, "java", 4)) {
         return NXT_APP_JAVA;
 
+    } else if (nxt_str_eq(&str, "wasm-wasi-http", 14)) {
+        return NXT_APP_WASM_WASI_HTTP;
+
     } else if (nxt_str_eq(&str, "wasm", 4)) {
         return NXT_APP_WASM;
     }
diff --git a/src/nxt_application.h b/src/nxt_application.h
index 64866db6..1e595b95 100644
--- a/src/nxt_application.h
+++ b/src/nxt_application.h
@@ -22,6 +22,7 @@ typedef enum {
     NXT_APP_RUBY,
     NXT_APP_JAVA,
     NXT_APP_WASM,
+    NXT_APP_WASM_WASI_HTTP,
 
     NXT_APP_UNKNOWN,
 } nxt_app_type_t;
@@ -104,6 +105,13 @@ typedef struct {
 } nxt_wasm_app_conf_t;
 
 
+typedef struct {
+    const char        *component;
+
+    nxt_conf_value_t  *access;
+} nxt_wasm_wasi_http_app_conf_t;
+
+
 struct nxt_common_app_conf_s {
     nxt_str_t                  name;
     nxt_str_t                  type;
@@ -126,13 +134,14 @@ struct nxt_common_app_conf_s {
     nxt_fd_t                   shared_queue_fd;
 
     union {
-        nxt_external_app_conf_t  external;
-        nxt_python_app_conf_t    python;
-        nxt_php_app_conf_t       php;
-        nxt_perl_app_conf_t      perl;
-        nxt_ruby_app_conf_t      ruby;
-        nxt_java_app_conf_t      java;
-        nxt_wasm_app_conf_t      wasm;
+        nxt_external_app_conf_t         external;
+        nxt_python_app_conf_t           python;
+        nxt_php_app_conf_t              php;
+        nxt_perl_app_conf_t             perl;
+        nxt_ruby_app_conf_t             ruby;
+        nxt_java_app_conf_t             java;
+        nxt_wasm_app_conf_t             wasm;
+        nxt_wasm_wasi_http_app_conf_t   wasm_wasi_http;
     } u;
 
     nxt_conf_value_t           *self;
diff --git a/src/nxt_conf_validation.c b/src/nxt_conf_validation.c
index f00b28b8..253f9cb1 100644
--- a/src/nxt_conf_validation.c
+++ b/src/nxt_conf_validation.c
@@ -1093,6 +1093,22 @@ static nxt_conf_vldt_object_t  nxt_conf_vldt_wasm_members[] = {
 };
 
 
+static nxt_conf_vldt_object_t  nxt_conf_vldt_wasm_wasi_http_members[] = {
+    {
+        .name       = nxt_string("component"),
+        .type       = NXT_CONF_VLDT_STRING,
+        .flags      = NXT_CONF_VLDT_REQUIRED,
+    }, {
+        .name       = nxt_string("access"),
+        .type       = NXT_CONF_VLDT_OBJECT,
+        .validator  = nxt_conf_vldt_object,
+        .u.members  = nxt_conf_vldt_wasm_access_members,
+    },
+
+    NXT_CONF_VLDT_NEXT(nxt_conf_vldt_common_members)
+};
+
+
 static nxt_conf_vldt_object_t  nxt_conf_vldt_wasm_access_members[] = {
     {
         .name       = nxt_string("filesystem"),
@@ -2617,6 +2633,7 @@ nxt_conf_vldt_app(nxt_conf_validation_t *vldt, nxt_str_t *name,
         { nxt_conf_vldt_object, nxt_conf_vldt_ruby_members },
         { nxt_conf_vldt_object, nxt_conf_vldt_java_members },
         { nxt_conf_vldt_object, nxt_conf_vldt_wasm_members },
+        { nxt_conf_vldt_object, nxt_conf_vldt_wasm_wasi_http_members },
     };
 
     ret = nxt_conf_vldt_type(vldt, name, value, NXT_CONF_VLDT_OBJECT);
diff --git a/src/nxt_main_process.c b/src/nxt_main_process.c
index 3f317d5e..42099be8 100644
--- a/src/nxt_main_process.c
+++ b/src/nxt_main_process.c
@@ -377,14 +377,29 @@ static nxt_conf_map_t  nxt_wasm_app_conf[] = {
 };
 
 
+static nxt_conf_map_t  nxt_wasm_wasi_http_app_conf[] = {
+    {
+        nxt_string("component"),
+        NXT_CONF_MAP_CSTRZ,
+        offsetof(nxt_common_app_conf_t, u.wasm_wasi_http.component),
+    },
+    {
+        nxt_string("access"),
+        NXT_CONF_MAP_PTR,
+        offsetof(nxt_common_app_conf_t, u.wasm_wasi_http.access),
+    },
+};
+
+
 static nxt_conf_app_map_t  nxt_app_maps[] = {
-    { nxt_nitems(nxt_external_app_conf),  nxt_external_app_conf },
-    { nxt_nitems(nxt_python_app_conf),    nxt_python_app_conf },
-    { nxt_nitems(nxt_php_app_conf),       nxt_php_app_conf },
-    { nxt_nitems(nxt_perl_app_conf),      nxt_perl_app_conf },
-    { nxt_nitems(nxt_ruby_app_conf),      nxt_ruby_app_conf },
-    { nxt_nitems(nxt_java_app_conf),      nxt_java_app_conf },
-    { nxt_nitems(nxt_wasm_app_conf),      nxt_wasm_app_conf },
+    { nxt_nitems(nxt_external_app_conf),        nxt_external_app_conf },
+    { nxt_nitems(nxt_python_app_conf),          nxt_python_app_conf },
+    { nxt_nitems(nxt_php_app_conf),             nxt_php_app_conf },
+    { nxt_nitems(nxt_perl_app_conf),            nxt_perl_app_conf },
+    { nxt_nitems(nxt_ruby_app_conf),            nxt_ruby_app_conf },
+    { nxt_nitems(nxt_java_app_conf),            nxt_java_app_conf },
+    { nxt_nitems(nxt_wasm_app_conf),            nxt_wasm_app_conf },
+    { nxt_nitems(nxt_wasm_wasi_http_app_conf),  nxt_wasm_wasi_http_app_conf },
 };
 
 
diff --git a/src/nxt_router.c b/src/nxt_router.c
index 4e3cb303..d3bb52dc 100644
--- a/src/nxt_router.c
+++ b/src/nxt_router.c
@@ -274,13 +274,14 @@ static const nxt_str_t http_prefix = nxt_string("HTTP_");
 static const nxt_str_t empty_prefix = nxt_string("");
 
 static const nxt_str_t  *nxt_app_msg_prefix[] = {
-    [NXT_APP_EXTERNAL]  = &empty_prefix,
-    [NXT_APP_PYTHON]    = &empty_prefix,
-    [NXT_APP_PHP]       = &http_prefix,
-    [NXT_APP_PERL]      = &http_prefix,
-    [NXT_APP_RUBY]      = &http_prefix,
-    [NXT_APP_JAVA]      = &empty_prefix,
-    [NXT_APP_WASM]      = &empty_prefix,
+    [NXT_APP_EXTERNAL]          = &empty_prefix,
+    [NXT_APP_PYTHON]            = &empty_prefix,
+    [NXT_APP_PHP]               = &http_prefix,
+    [NXT_APP_PERL]              = &http_prefix,
+    [NXT_APP_RUBY]              = &http_prefix,
+    [NXT_APP_JAVA]              = &empty_prefix,
+    [NXT_APP_WASM]              = &empty_prefix,
+    [NXT_APP_WASM_WASI_HTTP]    = &empty_prefix,
 };
 
 
diff --git a/src/wasm-wasi-http/.gitignore b/src/wasm-wasi-http/.gitignore
new file mode 100644
index 00000000..159e3885
--- /dev/null
+++ b/src/wasm-wasi-http/.gitignore
@@ -0,0 +1,3 @@
+Cargo.lock
+
+target
diff --git a/src/wasm-wasi-http/Cargo.toml b/src/wasm-wasi-http/Cargo.toml
new file mode 100644
index 00000000..76aac991
--- /dev/null
+++ b/src/wasm-wasi-http/Cargo.toml
@@ -0,0 +1,30 @@
+[package]
+name = "nxt-wasmtime"
+version = "0.1.0"
+edition = "2021"
+publish = false
+
+[lib]
+crate-type = ["cdylib"]
+
+[dependencies]
+anyhow = "1.0.75"
+bytes = "1.5.0"
+futures-util = { version = "0.3.29", default-features = false }
+http = "0.2.9"
+http-body = { version = "1.0.0-rc.2", default-features = false }
+http-body-util = "0.1.0-rc.2"
+tokio = { version = "1.33.0", default-features = false }
+wasmtime = { version = "14.0.2", default-features = false, features = ['component-model', 'cranelift'] }
+wasmtime-wasi = "14.0.4"
+wasmtime-wasi-http = "14.0.4"
+
+[build-dependencies]
+bindgen = "0.68.1"
+cc = "1.0.83"
+
+[profile.dev]
+panic = 'abort'
+
+[profile.release]
+panic = 'abort'
diff --git a/src/wasm-wasi-http/build.rs b/src/wasm-wasi-http/build.rs
new file mode 100644
index 00000000..5ea74f17
--- /dev/null
+++ b/src/wasm-wasi-http/build.rs
@@ -0,0 +1,33 @@
+use std::env;
+use std::path::PathBuf;
+
+fn main() {
+    // Tell cargo to invalidate the built crate whenever the wrapper changes
+    println!("cargo:rerun-if-changed=wrapper.h");
+
+    let bindings = bindgen::Builder::default()
+        .clang_args(["-I", "../"])
+        .clang_args(["-I", "../../build/include"])
+        .header("./wrapper.h")
+        // only generate bindings for `nxt_*` header files
+        .allowlist_file(".*nxt_.*.h")
+        // generates an "improper_ctypes" warning and we don't need it anyway
+        .blocklist_function("nxt_vsprintf")
+        // Tell cargo to invalidate the built crate whenever any of the
+        // included header files changed.
+        .parse_callbacks(Box::new(bindgen::CargoCallbacks))
+        // disable some features which aren't necessary
+        .layout_tests(false)
+        .derive_debug(false)
+        .generate()
+        .expect("Unable to generate bindings");
+
+    cc::Build::new()
+        .object("../../build/src/nxt_unit.o")
+        .compile("nxt-unit");
+
+    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());
+    bindings
+        .write_to_file(out_path.join("bindings.rs"))
+        .expect("Couldn't write bindings!");
+}
diff --git a/src/wasm-wasi-http/src/lib.rs b/src/wasm-wasi-http/src/lib.rs
new file mode 100644
index 00000000..af8b677c
--- /dev/null
+++ b/src/wasm-wasi-http/src/lib.rs
@@ -0,0 +1,549 @@
+use anyhow::{bail, Context, Result};
+use bytes::{Bytes, BytesMut};
+use http_body_util::combinators::BoxBody;
+use http_body_util::{BodyExt, Full};
+use std::ffi::{CStr, CString};
+use std::mem::MaybeUninit;
+use std::ptr;
+use std::sync::OnceLock;
+use tokio::sync::mpsc;
+use wasmtime::component::{Component, InstancePre, Linker};
+use wasmtime::{Config, Engine, Store};
+use wasmtime_wasi::preview2::{DirPerms, FilePerms, Table, WasiCtx, WasiCtxBuilder, WasiView};
+use wasmtime_wasi::{ambient_authority, Dir};
+use wasmtime_wasi_http::{WasiHttpCtx, WasiHttpView};
+
+#[allow(
+    non_camel_case_types,
+    non_upper_case_globals,
+    non_snake_case,
+    dead_code
+)]
+mod bindings {
+    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
+
+    pub const fn nxt_string(s: &'static str) -> nxt_str_t {
+        nxt_str_t {
+            start: s.as_ptr().cast_mut(),
+            length: s.len(),
+        }
+    }
+
+    pub unsafe fn nxt_unit_sptr_get(sptr: &nxt_unit_sptr_t) -> *const u8 {
+        sptr.base.as_ptr().offset(sptr.offset as isize)
+    }
+}
+
+#[no_mangle]
+pub static mut nxt_app_module: bindings::nxt_app_module_t = {
+    const COMPAT: [u32; 2] = [bindings::NXT_VERNUM, bindings::NXT_DEBUG];
+    let version = "0.1\0";
+    bindings::nxt_app_module_t {
+        compat: COMPAT.as_ptr().cast_mut(),
+        compat_length: COMPAT.len() * 4,
+        mounts: ptr::null(),
+        nmounts: 0,
+        type_: bindings::nxt_string("wasm-wasi-http"),
+        version: version.as_ptr().cast(),
+        setup: Some(setup),
+        start: Some(start),
+    }
+};
+
+static GLOBAL_CONFIG: OnceLock<GlobalConfig> = OnceLock::new();
+static GLOBAL_STATE: OnceLock<GlobalState> = OnceLock::new();
+
+unsafe extern "C" fn setup(
+    task: *mut bindings::nxt_task_t,
+    // TODO: should this get used?
+    _process: *mut bindings::nxt_process_t,
+    conf: *mut bindings::nxt_common_app_conf_t,
+) -> bindings::nxt_int_t {
+    handle_result(task, || {
+        let wasm_conf = &(*conf).u.wasm_wasi_http;
+        let component = CStr::from_ptr(wasm_conf.component).to_str()?;
+        let mut dirs = Vec::new();
+        if !wasm_conf.access.is_null() {
+            let dirs_ptr = bindings::nxt_conf_get_object_member(
+                wasm_conf.access,
+                &mut bindings::nxt_string("filesystem"),
+                ptr::null_mut(),
+            );
+            for i in 0..bindings::nxt_conf_object_members_count(dirs_ptr) {
+                let value = bindings::nxt_conf_get_array_element(dirs_ptr, i.try_into().unwrap());
+                let mut s = bindings::nxt_string("");
+                bindings::nxt_conf_get_string(value, &mut s);
+                dirs.push(
+                    std::str::from_utf8(std::slice::from_raw_parts(s.start, s.length))?.to_string(),
+                );
+            }
+        }
+
+        let result = GLOBAL_CONFIG.set(GlobalConfig {
+            component: component.to_string(),
+            dirs,
+        });
+        assert!(result.is_ok());
+        Ok(())
+    })
+}
+
+unsafe extern "C" fn start(
+    task: *mut bindings::nxt_task_t,
+    data: *mut bindings::nxt_process_data_t,
+) -> bindings::nxt_int_t {
+    handle_result(task, || {
+        let config = GLOBAL_CONFIG.get().unwrap();
+        let state = GlobalState::new(&config).context("failed to create initial state")?;
+        let res = GLOBAL_STATE.set(state);
+        assert!(res.is_ok());
+
+        let conf = (*data).app;
+        let mut wasm_init = MaybeUninit::uninit();
+        let ret = bindings::nxt_unit_default_init(task, wasm_init.as_mut_ptr(), conf);
+        if ret != bindings::NXT_OK as bindings::nxt_int_t {
+            bail!("nxt_unit_default_init() failed");
+        }
+        let mut wasm_init = wasm_init.assume_init();
+        wasm_init.callbacks.request_handler = Some(request_handler);
+
+        let unit_ctx = bindings::nxt_unit_init(&mut wasm_init);
+        if unit_ctx.is_null() {
+            bail!("nxt_unit_init() failed");
+        }
+
+        bindings::nxt_unit_run(unit_ctx);
+        bindings::nxt_unit_done(unit_ctx);
+
+        Ok(())
+    })
+}
+
+unsafe fn handle_result(
+    task: *mut bindings::nxt_task_t,
+    func: impl FnOnce() -> Result<()>,
+) -> bindings::nxt_int_t {
+    let rc = match func() {
+        Ok(()) => bindings::NXT_OK as bindings::nxt_int_t,
+        Err(e) => {
+            alert(task, &format!("{e:?}"));
+            bindings::NXT_ERROR as bindings::nxt_int_t
+        }
+    };
+    return rc;
+
+    unsafe fn alert(task: *mut bindings::nxt_task_t, msg: &str) {
+        let log = (*task).log;
+        let msg = CString::new(msg).unwrap();
+        ((*log).handler).unwrap()(
+            bindings::NXT_LOG_ALERT as bindings::nxt_uint_t,
+            log,
+            "%s\0".as_ptr().cast(),
+            msg.as_ptr(),
+        );
+    }
+}
+
+unsafe extern "C" fn request_handler(info: *mut bindings::nxt_unit_request_info_t) {
+    // Enqueue this request to get processed by the Tokio event loop, and
+    // otherwise immediately return.
+    let state = GLOBAL_STATE.get().unwrap();
+    state.sender.blocking_send(NxtRequestInfo { info }).unwrap();
+}
+
+struct GlobalConfig {
+    component: String,
+    dirs: Vec<String>,
+}
+
+struct GlobalState {
+    engine: Engine,
+    component: InstancePre<StoreState>,
+    global_config: &'static GlobalConfig,
+    sender: mpsc::Sender<NxtRequestInfo>,
+}
+
+impl GlobalState {
+    fn new(global_config: &'static GlobalConfig) -> Result<GlobalState> {
+        // Configure Wasmtime, e.g. the component model and async support are
+        // enabled here. Other configuration can include:
+        //
+        // * Epochs/fuel - enables async yielding to prevent any one request
+        //   starving others.
+        // * Pooling allocator - accelerates instantiation at the cost of a
+        //   large virtual memory reservation.
+        // * Memory limits/etc.
+        let mut config = Config::new();
+        config.wasm_component_model(true);
+        config.async_support(true);
+        let engine = Engine::new(&config)?;
+
+        // Compile the binary component on disk in Wasmtime. This is then
+        // pre-instantiated with host APIs defined by WASI. The result of
+        // this is a "pre-instantiated instance" which can be used to
+        // repeatedly instantiate later on. This will frontload
+        // compilation/linking/type-checking/etc to happen once rather than on
+        // each request.
+        let component = Component::from_file(&engine, &global_config.component)
+            .context("failed to compile component")?;
+        let mut linker = Linker::<StoreState>::new(&engine);
+        wasmtime_wasi_http::proxy::add_to_linker(&mut linker)?;
+        let component = linker
+            .instantiate_pre(&component)
+            .context("failed to pre-instantiate the provided component")?;
+
+        // Spin up the Tokio async runtime in a separate thread with a
+        // communication channel into it. This thread will send requests to
+        // Tokio and the results will be calculated there.
+        let (sender, receiver) = mpsc::channel(10);
+        std::thread::spawn(|| GlobalState::run(receiver));
+
+        Ok(GlobalState {
+            engine,
+            component,
+            sender,
+            global_config,
+        })
+    }
+
+    /// Worker thread that executes the Tokio runtime, infinitely receiving
+    /// messages from the provided `receiver` and handling those requests.
+    ///
+    /// Each request is handled in a separate subtask so processing can all
+    /// happen concurrently.
+    fn run(mut receiver: mpsc::Receiver<NxtRequestInfo>) {
+        let rt = tokio::runtime::Runtime::new().unwrap();
+        rt.block_on(async {
+            while let Some(msg) = receiver.recv().await {
+                let state = GLOBAL_STATE.get().unwrap();
+                tokio::task::spawn(async move {
+                    state.handle(msg).await.expect("failed to handle request")
+                });
+            }
+        });
+    }
+
+    async fn handle(&'static self, mut info: NxtRequestInfo) -> Result<()> {
+        // Create a "Store" which is the unit of per-request isolation in
+        // Wasmtime.
+        let data = StoreState {
+            ctx: {
+                let mut cx = WasiCtxBuilder::new();
+                // NB: while useful for debugging untrusted code probably
+                // shouldn't get raw access to stdout/stderr.
+                cx.inherit_stdout();
+                cx.inherit_stderr();
+                for dir in self.global_config.dirs.iter() {
+                    let fd = Dir::open_ambient_dir(dir, ambient_authority())
+                        .with_context(|| format!("failed to open directory '{dir}'"))?;
+                    cx.preopened_dir(fd, DirPerms::all(), FilePerms::all(), dir);
+                }
+                cx.build()
+            },
+            table: Table::default(),
+            http: WasiHttpCtx,
+        };
+        let mut store = Store::new(&self.engine, data);
+
+        // Convert the `nxt_*` representation into the representation required
+        // by Wasmtime's `wasi-http` implementation using the Rust `http`
+        // crate.
+        let request = self.to_request_builder(&info)?;
+        let body = self.to_request_body(&mut info);
+        let request = request.body(body)?;
+
+        let (sender, receiver) = tokio::sync::oneshot::channel();
+
+        // Instantiate the WebAssembly component and invoke its `handle`
+        // function which receives a request and where to put a response.
+        //
+        // Note that this is done in a sub-task to work concurrently with
+        // writing the response when it's available. This enables wasm to
+        // generate headers, write those below, and then compute the body
+        // afterwards.
+        let task = tokio::spawn(async move {
+            let (proxy, _) =
+                wasmtime_wasi_http::proxy::Proxy::instantiate_pre(&mut store, &self.component)
+                    .await
+                    .context("failed to instantiate")?;
+            let req = store.data_mut().new_incoming_request(request)?;
+            let out = store.data_mut().new_response_outparam(sender)?;
+            proxy
+                .wasi_http_incoming_handler()
+                .call_handle(&mut store, req, out)
+                .await
+                .context("failed to invoke wasm `handle`")?;
+            Ok::<_, anyhow::Error>(())
+        });
+
+        // Wait for the wasm to produce the initial response. If this succeeds
+        // then propagate that failure. If this fails then wait for the above
+        // task to complete to see if it failed, otherwise panic since that's
+        // unexpected.
+        let response = match receiver.await {
+            Ok(response) => response.context("response generation failed")?,
+            Err(_) => {
+                task.await.unwrap()?;
+                panic!("sender of response disappeared");
+            }
+        };
+
+        // Send the headers/status which will extract the body for the next
+        // phase.
+        let body = self.send_response(&mut info, response);
+
+        // Send the body, a blocking operation, over time as it becomes
+        // available.
+        self.send_response_body(&mut info, body)
+            .await
+            .context("failed to write response body")?;
+
+        // Join on completion of the wasm task which should be done by this
+        // point.
+        task.await.unwrap()?;
+
+        // And finally signal that we're done.
+        info.request_done();
+
+        Ok(())
+    }
+
+    fn to_request_builder(&self, info: &NxtRequestInfo) -> Result<http::request::Builder> {
+        let mut request = http::Request::builder();
+
+        request = request.method(info.method());
+        request = match info.version() {
+            "HTTP/0.9" => request.version(http::Version::HTTP_09),
+            "HTTP/1.0" => request.version(http::Version::HTTP_10),
+            "HTTP/1.1" => request.version(http::Version::HTTP_11),
+            "HTTP/2.0" => request.version(http::Version::HTTP_2),
+            "HTTP/3.0" => request.version(http::Version::HTTP_3),
+            version => {
+                println!("unknown version: {version}");
+                request
+            }
+        };
+
+        let uri = http::Uri::builder()
+            .scheme(if info.tls() { "https" } else { "http" })
+            .authority(info.server_name())
+            .path_and_query(info.target())
+            .build()
+            .context("failed to build URI")?;
+        request = request.uri(uri);
+
+        for (name, value) in info.fields() {
+            request = request.header(name, value);
+        }
+        Ok(request)
+    }
+
+    fn to_request_body(&self, info: &mut NxtRequestInfo) -> BoxBody<Bytes, anyhow::Error> {
+        // TODO: should convert the body into a form of `Stream` to become an async
+        // stream of frames. The return value can represent that here but for now
+        // this slurps up the entire body into memory and puts it all in a single
+        // `BytesMut` which is then converted to `Bytes`.
+        let mut body = BytesMut::with_capacity(info.content_length().try_into().unwrap());
+
+        // TODO: can this perform a partial read?
+        // TODO: how to make this async at the nxt level?
+        info.request_read(&mut body);
+
+        Full::new(body.freeze()).map_err(|e| match e {}).boxed()
+    }
+
+    fn send_response<T>(&self, info: &mut NxtRequestInfo, response: http::Response<T>) -> T {
+        info.init_response(
+            response.status().as_u16(),
+            response.headers().len().try_into().unwrap(),
+            response
+                .headers()
+                .iter()
+                .map(|(k, v)| k.as_str().len() + v.len())
+                .sum::<usize>()
+                .try_into()
+                .unwrap(),
+        );
+        for (k, v) in response.headers() {
+            info.add_field(k.as_str().as_bytes(), v.as_bytes());
+        }
+        info.send_response();
+
+        response.into_body()
+    }
+
+    async fn send_response_body(
+        &self,
+        info: &mut NxtRequestInfo,
+        mut body: BoxBody<Bytes, anyhow::Error>,
+    ) -> Result<()> {
+        loop {
+            // Acquire the next frame, and because nothing is actually async at the
+            // moment this should never block meaning that the `Pending` case
+            // should not happen.
+            let frame = match body.frame().await {
+                Some(Ok(frame)) => frame,
+                Some(Err(e)) => break Err(e),
+                None => break Ok(()),
+            };
+            match frame.data_ref() {
+                Some(data) => {
+                    info.response_write(&data);
+                }
+                None => {
+                    // TODO: what to do with trailers?
+                }
+            }
+        }
+    }
+}
+
+struct NxtRequestInfo {
+    info: *mut bindings::nxt_unit_request_info_t,
+}
+
+// TODO: is this actually safe?
+unsafe impl Send for NxtRequestInfo {}
+unsafe impl Sync for NxtRequestInfo {}
+
+impl NxtRequestInfo {
+    fn method(&self) -> &str {
+        unsafe {
+            let raw = (*self.info).request;
+            self.get_str(&(*raw).method, (*raw).method_length.into())
+        }
+    }
+
+    fn tls(&self) -> bool {
+        unsafe { (*(*self.info).request).tls != 0 }
+    }
+
+    fn version(&self) -> &str {
+        unsafe {
+            let raw = (*self.info).request;
+            self.get_str(&(*raw).version, (*raw).version_length.into())
+        }
+    }
+
+    fn server_name(&self) -> &str {
+        unsafe {
+            let raw = (*self.info).request;
+            self.get_str(&(*raw).server_name, (*raw).server_name_length.into())
+        }
+    }
+
+    fn target(&self) -> &str {
+        unsafe {
+            let raw = (*self.info).request;
+            self.get_str(&(*raw).target, (*raw).target_length.into())
+        }
+    }
+
+    fn content_length(&self) -> u64 {
+        unsafe {
+            let raw_request = (*self.info).request;
+            (*raw_request).content_length
+        }
+    }
+
+    fn fields(&self) -> impl Iterator<Item = (&str, &str)> {
+        unsafe {
+            let raw = (*self.info).request;
+            (0..(*raw).fields_count).map(move |i| {
+                let field = (*raw).fields.as_ptr().add(i as usize);
+                let name = self.get_str(&(*field).name, (*field).name_length.into());
+                let value = self.get_str(&(*field).value, (*field).value_length.into());
+                (name, value)
+            })
+        }
+    }
+
+    fn request_read(&mut self, dst: &mut BytesMut) {
+        unsafe {
+            let rest = dst.spare_capacity_mut();
+            let amt =
+                bindings::nxt_unit_request_read(self.info, rest.as_mut_ptr().cast(), rest.len());
+            // TODO: handle failure when `amt` is negative
+            let amt: usize = amt.try_into().unwrap();
+            dst.set_len(dst.len() + amt);
+        }
+    }
+
+    fn response_write(&mut self, data: &[u8]) {
+        unsafe {
+            let rc = bindings::nxt_unit_response_write(self.info, data.as_ptr().cast(), data.len());
+            assert_eq!(rc, 0);
+        }
+    }
+
+    fn init_response(&mut self, status: u16, headers: u32, headers_size: u32) {
+        unsafe {
+            let rc = bindings::nxt_unit_response_init(self.info, status, headers, headers_size);
+            assert_eq!(rc, 0);
+        }
+    }
+
+    fn add_field(&mut self, key: &[u8], val: &[u8]) {
+        unsafe {
+            let rc = bindings::nxt_unit_response_add_field(
+                self.info,
+                key.as_ptr().cast(),
+                key.len().try_into().unwrap(),
+                val.as_ptr().cast(),
+                val.len().try_into().unwrap(),
+            );
+            assert_eq!(rc, 0);
+        }
+    }
+
+    fn send_response(&mut self) {
+        unsafe {
+            let rc = bindings::nxt_unit_response_send(self.info);
+            assert_eq!(rc, 0);
+        }
+    }
+
+    fn request_done(self) {
+        unsafe {
+            bindings::nxt_unit_request_done(self.info, bindings::NXT_UNIT_OK as i32);
+        }
+    }
+
+    unsafe fn get_str(&self, ptr: &bindings::nxt_unit_sptr_t, len: u32) -> &str {
+        let ptr = bindings::nxt_unit_sptr_get(ptr);
+        let slice = std::slice::from_raw_parts(ptr, len.try_into().unwrap());
+        std::str::from_utf8(slice).unwrap()
+    }
+}
+
+struct StoreState {
+    ctx: WasiCtx,
+    http: WasiHttpCtx,
+    table: Table,
+}
+
+impl WasiView for StoreState {
+    fn table(&self) -> &Table {
+        &self.table
+    }
+    fn table_mut(&mut self) -> &mut Table {
+        &mut self.table
+    }
+    fn ctx(&self) -> &WasiCtx {
+        &self.ctx
+    }
+    fn ctx_mut(&mut self) -> &mut WasiCtx {
+        &mut self.ctx
+    }
+}
+
+impl WasiHttpView for StoreState {
+    fn ctx(&mut self) -> &mut WasiHttpCtx {
+        &mut self.http
+    }
+    fn table(&mut self) -> &mut Table {
+        &mut self.table
+    }
+}
+
+impl StoreState {}
diff --git a/src/wasm-wasi-http/wrapper.h b/src/wasm-wasi-http/wrapper.h
new file mode 100644
index 00000000..93f3014a
--- /dev/null
+++ b/src/wasm-wasi-http/wrapper.h
@@ -0,0 +1,5 @@
+#include <nxt_main.h>
+#include <nxt_unit.h>
+#include <nxt_unit_request.h>
+#include <nxt_unit_typedefs.h>
+#include <nxt_application.h>
diff --git a/wasm-wasi-http-example/.gitignore b/wasm-wasi-http-example/.gitignore
new file mode 100644
index 00000000..eb5a316c
--- /dev/null
+++ b/wasm-wasi-http-example/.gitignore
@@ -0,0 +1 @@
+target
diff --git a/wasm-wasi-http-example/Cargo.lock b/wasm-wasi-http-example/Cargo.lock
new file mode 100644
index 00000000..11cf7ef2
--- /dev/null
+++ b/wasm-wasi-http-example/Cargo.lock
@@ -0,0 +1,303 @@
+# This file is automatically @generated by Cargo.
+# It is not intended for manual editing.
+version = 3
+
+[[package]]
+name = "anyhow"
+version = "1.0.75"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a4668cab20f66d8d020e1fbc0ebe47217433c1b6c8f2040faf858554e394ace6"
+
+[[package]]
+name = "bitflags"
+version = "2.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "327762f6e5a765692301e5bb513e0d9fef63be86bbc14528052b1cd3e6f03e07"
+
+[[package]]
+name = "equivalent"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5443807d6dff69373d433ab9ef5378ad8df50ca6298caf15de6e52e24aaf54d5"
+
+[[package]]
+name = "example"
+version = "0.1.0"
+dependencies = [
+ "wit-bindgen",
+]
+
+[[package]]
+name = "hashbrown"
+version = "0.14.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f93e7192158dbcda357bdec5fb5788eebf8bbac027f3f33e719d29135ae84156"
+
+[[package]]
+name = "heck"
+version = "0.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "95505c38b4572b2d910cecb0281560f54b440a19336cbbcb27bf6ce6adc6f5a8"
+dependencies = [
+ "unicode-segmentation",
+]
+
+[[package]]
+name = "id-arena"
+version = "2.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "25a2bc672d1148e28034f176e01fffebb08b35768468cc954630da77a1449005"
+
+[[package]]
+name = "indexmap"
+version = "2.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d530e1a18b1cb4c484e6e34556a0d948706958449fca0cab753d649f2bce3d1f"
+dependencies = [
+ "equivalent",
+ "hashbrown",
+ "serde",
+]
+
+[[package]]
+name = "itoa"
+version = "1.0.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "af150ab688ff2122fcef229be89cb50dd66af9e01a4ff320cc137eecc9bacc38"
+
+[[package]]
+name = "leb128"
+version = "0.2.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "884e2677b40cc8c339eaefcb701c32ef1fd2493d71118dc0ca4b6a736c93bd67"
+
+[[package]]
+name = "log"
+version = "0.4.20"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b5e6163cb8c49088c2c36f57875e58ccd8c87c7427f7fbd50ea6710b2f3f2e8f"
+
+[[package]]
+name = "proc-macro2"
+version = "1.0.69"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "134c189feb4956b20f6f547d2cf727d4c0fe06722b20a0eec87ed445a97f92da"
+dependencies = [
+ "unicode-ident",
+]
+
+[[package]]
+name = "quote"
+version = "1.0.33"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5267fca4496028628a95160fc423a33e8b2e6af8a5302579e322e4b520293cae"
+dependencies = [
+ "proc-macro2",
+]
+
+[[package]]
+name = "ryu"
+version = "1.0.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1ad4cc8da4ef723ed60bced201181d83791ad433213d8c24efffda1eec85d741"
+
+[[package]]
+name = "semver"
+version = "1.0.20"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "836fa6a3e1e547f9a2c4040802ec865b5d85f4014efe00555d7090a3dcaa1090"
+
+[[package]]
+name = "serde"
+version = "1.0.190"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "91d3c334ca1ee894a2c6f6ad698fe8c435b76d504b13d436f0685d648d6d96f7"
+dependencies = [
+ "serde_derive",
+]
+
+[[package]]
+name = "serde_derive"
+version = "1.0.190"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "67c5609f394e5c2bd7fc51efda478004ea80ef42fee983d5c67a65e34f32c0e3"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "serde_json"
+version = "1.0.108"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3d1c7e3eac408d115102c4c24ad393e0821bb3a5df4d506a80f85f7a742a526b"
+dependencies = [
+ "itoa",
+ "ryu",
+ "serde",
+]
+
+[[package]]
+name = "smallvec"
+version = "1.11.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "942b4a808e05215192e39f4ab80813e599068285906cc91aa64f923db842bd5a"
+
+[[package]]
+name = "spdx"
+version = "0.10.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b19b32ed6d899ab23174302ff105c1577e45a06b08d4fe0a9dd13ce804bbbf71"
+dependencies = [
+ "smallvec",
+]
+
+[[package]]
+name = "syn"
+version = "2.0.38"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e96b79aaa137db8f61e26363a0c9b47d8b4ec75da28b7d1d614c2303e232408b"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "unicode-ident",
+]
+
+[[package]]
+name = "unicode-ident"
+version = "1.0.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b"
+
+[[package]]
+name = "unicode-segmentation"
+version = "1.10.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1dd624098567895118886609431a7c3b8f516e41d30e0643f03d94592a147e36"
+
+[[package]]
+name = "unicode-xid"
+version = "0.2.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f962df74c8c05a667b5ee8bcf162993134c104e96440b663c8daa176dc772d8c"
+
+[[package]]
+name = "wasm-encoder"
+version = "0.36.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "53ae0be20bf87918df4fa831bfbbd0b491d24aee407ed86360eae4c2c5608d38"
+dependencies = [
+ "leb128",
+]
+
+[[package]]
+name = "wasm-metadata"
+version = "0.10.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5621910462c61a8efc3248fdfb1739bf649bb335b0df935c27b340418105f9d8"
+dependencies = [
+ "anyhow",
+ "indexmap",
+ "serde",
+ "serde_derive",
+ "serde_json",
+ "spdx",
+ "wasm-encoder",
+ "wasmparser",
+]
+
+[[package]]
+name = "wasmparser"
+version = "0.116.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "53290b1276c5c2d47d694fb1a920538c01f51690e7e261acbe1d10c5fc306ea1"
+dependencies = [
+ "indexmap",
+ "semver",
+]
+
+[[package]]
+name = "wit-bindgen"
+version = "0.13.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "38726c54a5d7c03cac28a2a8de1006cfe40397ddf6def3f836189033a413bc08"
+dependencies = [
+ "bitflags",
+ "wit-bindgen-rust-macro",
+]
+
+[[package]]
+name = "wit-bindgen-core"
+version = "0.13.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c8bf1fddccaff31a1ad57432d8bfb7027a7e552969b6c68d6d8820dcf5c2371f"
+dependencies = [
+ "anyhow",
+ "wit-component",
+ "wit-parser",
+]
+
+[[package]]
+name = "wit-bindgen-rust"
+version = "0.13.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0e7200e565124801e01b7b5ddafc559e1da1b2e1bed5364d669cd1d96fb88722"
+dependencies = [
+ "anyhow",
+ "heck",
+ "wasm-metadata",
+ "wit-bindgen-core",
+ "wit-component",
+]
+
+[[package]]
+name = "wit-bindgen-rust-macro"
+version = "0.13.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4ae33920ad8119fe72cf59eb00f127c0b256a236b9de029a1a10397b1f38bdbd"
+dependencies = [
+ "anyhow",
+ "proc-macro2",
+ "quote",
+ "syn",
+ "wit-bindgen-core",
+ "wit-bindgen-rust",
+ "wit-component",
+]
+
+[[package]]
+name = "wit-component"
+version = "0.17.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "480cc1a078b305c1b8510f7c455c76cbd008ee49935f3a6c5fd5e937d8d95b1e"
+dependencies = [
+ "anyhow",
+ "bitflags",
+ "indexmap",
+ "log",
+ "serde",
+ "serde_derive",
+ "serde_json",
+ "wasm-encoder",
+ "wasm-metadata",
+ "wasmparser",
+ "wit-parser",
+]
+
+[[package]]
+name = "wit-parser"
+version = "0.12.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "43771ee863a16ec4ecf9da0fc65c3bbd4a1235c8e3da5f094b562894843dfa76"
+dependencies = [
+ "anyhow",
+ "id-arena",
+ "indexmap",
+ "log",
+ "semver",
+ "serde",
+ "serde_derive",
+ "serde_json",
+ "unicode-xid",
+]
diff --git a/wasm-wasi-http-example/Cargo.toml b/wasm-wasi-http-example/Cargo.toml
new file mode 100644
index 00000000..2bd03ca4
--- /dev/null
+++ b/wasm-wasi-http-example/Cargo.toml
@@ -0,0 +1,10 @@
+[package]
+name = "example"
+version = "0.1.0"
+edition = "2021"
+
+[lib]
+crate-type = ['cdylib']
+
+[dependencies]
+wit-bindgen = "0.13.0"
diff --git a/wasm-wasi-http-example/src/lib.rs b/wasm-wasi-http-example/src/lib.rs
new file mode 100644
index 00000000..df702d5a
--- /dev/null
+++ b/wasm-wasi-http-example/src/lib.rs
@@ -0,0 +1,102 @@
+wit_bindgen::generate!({
+    world: "wasi:http/proxy",
+    exports: {
+        "wasi:http/incoming-handler": Component,
+    },
+});
+
+use crate::exports::wasi::http::incoming_handler;
+use crate::wasi::http::types;
+use crate::wasi::io::poll;
+use crate::wasi::io::streams::StreamError;
+use std::fmt::Write;
+
+struct Component;
+
+macro_rules! uwriteln {
+    ($($fmt:tt)*) => (writeln!($($fmt)*).unwrap());
+}
+
+impl incoming_handler::Guest for Component {
+    fn handle(request: types::IncomingRequest, response_outparam: types::ResponseOutparam) {
+        let mut content = String::new();
+        uwriteln!(content, " * Welcome to the component model in Rust! *\n");
+        uwriteln!(content, "[Request Info]");
+        if let Some(path) = request.path_with_query() {
+            uwriteln!(content, "REQUEST_PATH = {path}");
+        }
+        uwriteln!(content, "METHOD = {}", method_to_str(&request.method()));
+        if let Some(scheme) = request.scheme() {
+            uwriteln!(content, "SCHEME = {}", scheme_to_str(&scheme));
+        }
+        if let Some(name) = request.authority() {
+            uwriteln!(content, "AUTHORITY = {name}");
+        }
+        uwriteln!(content, "\n[Request Headers]");
+        for (key, value) in request.headers().entries() {
+            uwriteln!(content, "{key} = {}", String::from_utf8_lossy(&value));
+        }
+
+        let body = request.consume().expect("failed to consume request");
+        let reader = body.stream().expect("failed to get a reading stream");
+        let mut any = false;
+        loop {
+            match reader.read(64 * 1024) {
+                Ok(list) => {
+                    if list.is_empty() {
+                        poll::poll_one(&reader.subscribe());
+                        continue;
+                    }
+                    if !any {
+                        uwriteln!(content, "\n[Request Data]");
+                        any = true;
+                    }
+                    content.push_str(&String::from_utf8_lossy(&list));
+                }
+                Err(StreamError::LastOperationFailed(_)) => panic!("read failed"),
+                Err(StreamError::Closed) => break,
+            }
+        }
+
+        // Generate the response.
+        let headers = types::Headers::new(&[]);
+        headers.append("content-type", b"text/plain");
+        headers.append("content-length", format!("{}", content.len()).as_bytes());
+        let response = types::OutgoingResponse::new(200, &headers);
+        let outgoing_body = response.write().expect("failed to get write stream");
+
+        // Send the headers.
+        types::ResponseOutparam::set(response_outparam, Ok(response));
+
+        // Write the body.
+        outgoing_body
+            .write()
+            .expect("failed to get write stream")
+            .blocking_write_and_flush(content.as_bytes())
+            .expect("failed to write");
+        types::OutgoingBody::finish(outgoing_body, None);
+    }
+}
+
+fn method_to_str(method: &types::Method) -> &str {
+    match method {
+        types::Method::Get => "GET",
+        types::Method::Head => "HEAD",
+        types::Method::Post => "POST",
+        types::Method::Put => "PUT",
+        types::Method::Delete => "DELETEE",
+        types::Method::Connect => "CONNECT",
+        types::Method::Options => "OPTIONS",
+        types::Method::Trace => "TRACE",
+        types::Method::Patch => "PATCH",
+        types::Method::Other(s) => s,
+    }
+}
+
+fn scheme_to_str(scheme: &types::Scheme) -> &str {
+    match scheme {
+        types::Scheme::Http => "http",
+        types::Scheme::Https => "https",
+        types::Scheme::Other(s) => s,
+    }
+}
diff --git a/wasm-wasi-http-example/wasi_snapshot_preview1.reactor.wasm b/wasm-wasi-http-example/wasi_snapshot_preview1.reactor.wasm
new file mode 100644
index 0000000000000000000000000000000000000000..e490be4f1216a32fd12213ebf370b4be658b6425
GIT binary patch
literal 109411
zcmeFa31DPbc_w<#y|qcDrFyg5-EDJKZrkle>Z+1dl5CbPL17z6Y?cHkgvhmAwMs3i
z)K#T!H`s0i2Alv1drTl169_N?Gr*99Y!fH%CE+oUN0vzlAqiw4LlQzVS?0}TlE?eL
zbI!f@+)_!cw!7@W6GmNkJKKN${r}H7R;9fvEXxuP+ehyf=dHUfasS=%^Y`C>9@jSi
zan9e5f8*!R%ikD&ahv21{%75t@GtE9&x`Y@0{=Mj4IWr`%kS|h#p3)wAE9<tBX85P
z0{<nxQ~zU6R89CnN92ucLY7yz_se(uSM?7Ucq>2V19>64iWc$C?=>z5<ZBKSH+l@R
zG&;vIpU1xh1Mci!9XsK8YiAOx-fFXT&bF+Z&Q{uun-?1^Ui)0T<E<WFZ+XpiZ>@bI
zH&K|#jkjv!g<N5BJf9oS&yJq-I^*?5%d2&ot%ldOtQ%zU+Dfx_s(t)yWo2btUiT_I
z*z(%Vm5olLxn^1T7R~B%tIf4$r@7Xs?X0l4h(?{Y=GlvHO_mbZcY~&LZr$q%mn&Yj
z>UEZy^_SPZcCFP|2XrPX^)rpOXW2Wi<(iifLL04`H(qZw*I(`f`rNp;)@hv^Z+BW=
zW!18FUgMD-{c4|EtBuzyor>k`yrRQBDk3frB2ToQHtK0NUg24>o%iQpkN%u(H9DRZ
z-+3hmLaZP6TCHYlyw<E^I9JPgZ#0i9fcKp7{ate<%U{gYjP)1+rnerD*SVc_<ZxF<
z8f)ttfTu>4oebqjR}IaLj#<Ud;dyzFArady20^avQAZ7M>3}9Q-#Is4=~#)Kck7C-
z@r5*cG4s`{V=XYzGmpPxy{NP0tyNY%jxf3N5nkB?Xzg>WD~+{NtSPngntEa7#+s~%
z#3CVov8;Qby-_7sta{eKPVn(*{%9hII1$z|xRYA0@@p{(!mPygseHY;veHXlUEYN^
z{H{`6@ht0tMF;rp_)4SQvC`Mdc3PFSdUN%-`svkLhU`?m9<QG3K(-EzE-b888fy!y
z&HBcQx3Dl&t5h2cAchr)TWk23thlz)I1Yi{Xf@YXAtriNEv2^cjb-h)=rDU#X`S3)
z-4ORX$E2(e|B&1!B!4^8sQB#ZA{hSFJ*txofBf;)ceF=+m38Pnb+f{YkdVEInZR3I
zshn(I3<vC05k+LDu?nOZ+4&6gV#k~TYxIfL(e8k!Tm)ne^#C>NAT!DAyek1)Fc2z$
z3+vjm^SXL<$>)}PpI9~2o!Og<s3u@l#>hBPevd9f*10`k4b`+leQ$iJ(q6iliR(pk
zk;*P|1}B5g1(MuUY!!P5rM!G+Im$pGo9lS3)y7(7Wn2k{Uaan_E}q?0#IlY`rrCzM
z;&s}`JGJ#*wRCF?_-tGiv8)>dt{c=XB}}h+uH33OvV>(RImV&2J9TJ~z3Lbw6H%|N
zePco6-aU<;ygtSkmX!@YMA61tuZjnB#f>#<U!)^|Zm;kCj^MSmuLl&iY-leV3V<a)
z^Uco4tm4fUP4DZjfql@HYj+h}fN@h5_|Bhz?KS<twu>kdl99%CqKE{7FjBrsi@C9O
za(w3%1-cnVA1de*wI#21YFrsVJ2G7YTP|9Usv)tHAx-#%9IYW3lM>9(cp&{Yz;kv~
zX&{les8m(uIGy(JzWwRp1I_{d|FX-SgM-fCfddB*TygoK1N#pR4<2$393DI{oY{Zm
z%B!B{?st#uAGQYf9l*tbea`+dC*xkVH{oO)Ct+C!(u2-{!NEcNS=p?Ua4g43r_+f9
z{@G{kvj+Fe|6Lu6i*+GH;!ym&C|POaAB(sAC;8SyVV~5{8msHgRwq!@o~538_e7pP
zI|a3>y#UO%o--mZX#=YV&rNG>O}@T$kAD|_ar>}zouCa>;&~(Lo=So&^!$Ov`hs>r
zydceMDvdCstnW_Y4qwAJaR*;eG)OD$g~Pa8tWz}0DqgfNyoaD&P@2q(_eY<$8Yh>a
z8NOtckLgA7i+_*&(0{@Tq>=x<2h0!oSSdCyWw+paf_`$>h`J1_`abpq@8kmrhy~h6
z*7tLW>k4gOmc+Fz`~!pf3g1~j$N|En+E}f6EqMBH*Y><qRz+UXG_CTg<E^Y%HFiMN
zRzI*_=`1ZMyK^CsNY>&W`8+brlb1)Ig(F%TkZ&l(t%ka$a$qeF%jfK^e0NH<ri@9W
zwUxB~PL6hUNZx6)&RWaJTV<O`z+25Ut&WA}n%7)hwAKgKTg}>n6bGjV<#nq<hg2)w
z2Fs`~oNIV1b*nw7Yz{f&oiwG~LZw#o);re5fV_jV?~HXuUALhhTW5#m^Y+pP81~sU
z>z=^{i9`!{3F=u`Sn?|C3)M>7b7F%J{)p3l{eTeXuYLgkvr4&B+1OEeX`fL4xz@1d
zieW4B7(d8b$84+gPrv=%H`uoh3;TqN`+xbC<3F+Zq%^dQkFui7g0Ag4nO|ekF?%SU
z=Jzqaa`2_?isjPz<&x#vr%q?_;d0h-?K@E5hhK#PC~TEdtc%Y@@cj9x7ZhEzW2`V%
za&NYd<L4W{`wJgV6s;TG*!)*M{o2?3)<@s<3+{|{HE#du>+g8q>)!wHFXHwvZvXrX
z?|9AczVS~#@n5YOYad^K>HqrhJHPSpC%=Mw)|Xx`U6Xkodr<nK$UG#w5-a`UW7aMH
zYg@g>xBqMZE!O4u{n{6Q<!#BLtnP3B>UUoA_n&*$oBt-PZY21A@Mgabp`KatzK=ur
z<GmLc0=h(~eDkq~-|)^i{qZNhs-g0gzxdpTKky@e^2xsqhq31=9L8T-!7!eD7=H0P
z1BSnMA#4U@NlE|o7w>qVPf1?@ZM^Z1e%V!&^wrP2<-flAtM4XZ5oiAP>#us%2fz95
zU;0apGk^Y9@A{8_@Y(mg`I{lmXi7q@TTEMSS@9d!PLF{P*(Wj|AjM_Db~67<v7F2Y
z`2@Tp{jeQjRgTZ9Tri7e@|Fi4bu>#6U@2fAr(AnEYnSj`vJKZR@*CGF1?`H_G;SpY
zIw2ErqD;hzG7+bXiQsjFi8v+`dA$#I$7dq)wa-Kx%|x7#i8%97CL+K0nTVqxDW8Q*
z<PRNT8%#Wa3>h*wC|Tw)J2e&~q>6URjg^N*e~0}W7Z~>Z-#_-?+y3ygfBdmQB9k-!
zwZ|U(hyU@WpZMh0Br*X6-+0H{{-59e($D{+L?$`hgPH;L20?#^^Pes-oYLQZ`W?S#
zQ3L=vG#w}rAiF-aeb?;_P#q#q%C(e%p6P#xMNmE>owt+CoNq%i+o<|upSP9`d2E3w
z11hjU1$`Bz|J{e*mYkrELhw6;fj?=o{Bto8Gq{QE^I34`$0Sd73^mYlac7{K()oUa
z-+}wsRQSMcpyW|2bbw_}XL&5{oPd7EYJlvq<!lUBng1X;zi@d2weV&O1VMI1x`-{0
z;aa~E%VXqTDJq8XTZgT5+O-2*E)kb)#nJ7MquWuAZbvz~-Nn)II>OOylcNXdWcwUl
zzV<n~O%8q7wYzjGbReQr$uho9CCjke&^|-1-rr#a=+y6F{B}$@J~};Soyr>c<ceeV
zC;!#SI?`G=W`F8mow3-E03_zE89QU201Dxg7;Om{7Fl8pq!{c0$<BxyF-S7Ilv&RF
zJIO-f04Ul+Ko#KI{%owsD%D*k>lE48kgf6KStzH?hFj2}VKz+S)-W4x#I0#IT+P=8
zeqgdoheNX=kQExR`gMpOT2`<cQ&#Bjd|Bb+5v%UTiGFoGklI^x-IUsdiYc`@98+rR
z;rLQ}%i*M!F`u!_8>FR$SsMazOLmcxq)!eI1Arg1w5pi?q=8ScSPgW#IQAr2(wL(f
z1D8T`C2PzA%1MSr#x&;eiE{$q5cMz-<U?dVC>MkEngwct{h-I}>@F9gG8ZM5eYiJ?
zg~Vsr*iRZ4`tMI%sC{~Cp%&9ZO$)5vvQ3GvtSCK$vP}S)Bq{;1@C)t+PN$_HnI8Ne
zU}pZ8Bnl-39Wc9H!DsU4f2$~W0m1jnhTwbb2?)NQ>@E0ECHN8;suX-^Y*+AYEwjHZ
z1mAz#l7-nPpqqb)60~&xa_PR)P^TccAlj%6Sx~5YNJhz{48`4+#-ZeKN;1-00Q8Ab
zZ?fzYuA?fYdIs6p8H+;#4nZEWC5TA2c8~PeN}t1W$)=FBz^x!M<E8cGY+TDq*0(Dw
z-G95X^2da2pSSPVQ2{s5u}Y~ihp5K?Tx-O(ghO!-<r}E?0Or)SuXi%@*8Br+|LZR~
z^H%2L5+$DjJiv?8y!E1C`H7XKMt5*|+P3b^0*$_ZSb#ZYUd>9z;MEsye8!P@#p+$(
zN9d$Cb<9z=DLNM0)G-Rm%xh%F;PUI;G1wA8$8cq#H;&)2gd5i#dr)>PfzG%I)v=iL
z8u}fJrT;prlWIRr>Bv}I!pbSd;egac7>8{4LncB46VD7%gjM6lGoO=Phcz4<OMuj%
zC(|+pMg69g`6;O_$Bv5>%pW`+;u}E<mS1LG%d(iH*tnIFWE&sCRN-zQ^EMV8i&Gj%
zm(NZ3(Pq#wcy$dk$YppWjGi3Ct!V~j_}XBpa4VvdLG&ch>~!=*zxK@_=?G$#X6S)c
znr5;t<D1E{jDBXAL;%Ae(I(+02wJfW{=&fp?yY#~Ti<d{`#!FI4LI-%^n1W>Fuc8w
zL@gjHju~k!pD)@O=$Hq=gn<X5^qw4fa|wYv@?Id5fI5kP=oZZUq(moBDJSsZoN~n+
zVrB2imF(vZ16Qc9W&l}A1<k-8@d506Ty8=I0V+i-YS)ce)CX}JMWv{bkWxMI196Y;
z)8QX!MCz9Y0)R){Z1t=0k8j`j&%}DW-Zin4WPM@>LGnM+YlPTo{wiXJkr|_ZgYzT3
zV^-;irgcZsdg<mdi<IlA5eFfQWAHmiC^r(aI7qLw5%<jCK1#W4aWm!WkOe)`c<ocJ
z^uM#pDCMF9hJ#C&@hMl9(a(&D!=MJoNUM^yDau7-K3;*>X~OO6cmu-i_jv!@P~hkZ
z6PrA%(6>T#q4s4U3S<Sy;_trYkdR$V5%Q;T8@R=!wx_%ocImU~!_4a_3LsNKy{?`4
zyc8-R?EPa1z!T5NF<dM2h-3jmPKb*ih<eI%_D3>Qd>pu7FfU*NhyBSBM8;>~gTR|6
zOk|vNg(*gE#I1>pSM#+YMh>GQ!<!aNj!@oK{n|%HL2oOoG?9^2n#icj_{b>B=w}8p
z_H`J6H0<{<{(mPNeqnq543g=iaQKz&8~=l-a0uvK3x^1`YvB;3d8yQC;Q&I78AJ;f
z5C{j-D-=O|p%g*Tb>{V21r)vtXi){kov#8)K_Zd<rjT}zk#xcY8kfXrs(?}2g@zHK
z-4rV7B}g>V>(>$5J%}ny+GUj{?dmcS+SSiY+SP)ji(_pTBz+xkH?Qj3cz-Nq$3p|H
zE2yFn2@ZkBhyhYK1RBWZU>(JRqcIG)m&rn#ejo?q9yiFxgk_Zgv$rxoLivz|C4a{-
zEH>a?Ze>~KgO!J+jRWCim9AeNx9Eb%CQ8Chl)fcSmz>)nC&cLy$Fc>pIHv8?ym(zU
zIscgTpqoUQ48_^uF<g#Y2g@bVVS~_epwLUweI|aiV7b|iD3t}=8pwGAZcV|G<!eK*
z9708hLM`XBF;l73FAbEEO0oq7I-AJ+vy_@PXom)!i;GlA(8~fdP1#e4A()3WKV&1B
zhx`JEq0Zs+LuFXLvEbW&k1aq%9mmn5^9fI?(FB)Ccm$V8c)E;Fc(P0{D1p27Yl;G)
z+3#VLoUsHIbA_?ctmeP<tv~ygHI|xx;9vgi8DmL_kal|h{QP}zWr@>=vq?8O|EuR;
zgFE{)kvEokI|&4qI^LftrB3tB8N6)qqEpJ?!YUmjeYDsL91ZbO49~``>km@}PL8F(
zo!!(7QlN#KoN>TBT<aDAEzM0J3V<#E!{EpWH8LY8Mq-1Bn|^Iv#Qj)nXc@u};n*km
zANcb><Ga8YA#3v!I=h$ycqur8QWz<zOwIt8gmMOT^9HMnH&_wAphjM@nT-WFA&C?m
zp>#xY4d=OdND!fq;<S$bmtv>OH(S?Z@Q__m``!-C1jjc(kB7YCMxt{l$gak%!7DB@
zWYA4dWK9TSMd*oDn)JlLmq|~$OoX2Fvk2D#J@soC-SpJAVLTd(prQ8C*+9TvW^tE6
z49B!-5W^=YB~pUu3F{bmm$Xkr@Gfx&@d?NSnFK^FBgbScxwTc91iCoX3XkJQi<TQ<
z&qmNCVn8!P%@i$6^D;#X>obCy0lI9J^CvSzq6RdpjG~LI(npu4BIzwamwpf9D^zDj
ze1G#JB5*hpV*;Epc@@|S7z>^l_Ay28Y($xvHCfiv$9gI=a6Kr*(aH?(;54I{H}n}8
z!MHW`8QZp`6o*j^CE#Cud4B>D0KV>r1T-A`g~PC+r|pNu7<^XOJ8u?a1H6Agj1BVs
zo-q*M_0Ia(5T7oM4fF2qu@U~<H8#qhJI6BoxovC@2B(^O4do1a2d&}+&|bdXJ8zBc
za}&M{!rgv+F?uK8lcSDw`{d`(yTkZH;bZ(K2iN@Jd$XhNs5|_U!(;o?C_SV~A6$0R
zJxUL%(s1Nm@3^Y;usiGyqVztLM)~BO(2vlQq|E1`r(vK+Jt<X>gbyMI>;*)tn?gOH
zU?~V^@w0En$>C@J4EihF%!~uW#N9LFz<Qu`q{!SWMdrLv4*G=DAIG6y`uZ7M_BM&W
zjvr0*ce@c8aTjh48F43WO`^YzuMK??Q@|<N>^9TdivK<$C0MB`C0MCR_I@Fs?xou0
zKQ!b-9Et=`jpi0or5xCa`o~RBhXzQfFyQ?`q|%j+Wj;!*ITVC|`v!!7^*tFtNcfYx
zNiljv_^}zS7=0mXiQB&Ct(TExpWuI+xr=Eh#poU*Qd2VmYw+E)wz9<W)DOwvqs$MH
zJ)lY&4l*1gZE@U1Y;lR6{c>Xm%v?_lC=NY~sxWlRo5%^?6G2X0CW4##nSq)BfpqG2
z>8hJ;@xG3?8xi|9-rq?$43-A@_n(JjH`aw-X2=hC!2jItke^d>U@bqF>#B%+(1F3d
z@pA@OkB$j)QK15>4`dVbnTKF>Bt8hi0tToa-+$i+#|Gx@F?<+vlg|`4!=8EOGVB!h
zp=Su{<pV`j9CK5*h*|uAQRYzp(CN}p*l0{O>ZnE)>-HN>vQcp44@%E)GHf)3My0wX
zo+<XC(aWI12aO_&4^ckXxkVtjr|g=p;3o43J`E|VqnnzNBoyF_xJ_jp@a+rmVGiGs
zqW(82Dyu~DHR!)<X<pzEP$>62S`09<K%UBh{hbr=q&bH%mJqp9c!p{GjtX%8)=-#$
zPUlwKCnt#%HuMUImTZj5KKv>af<R20`It6yOd$FY758&rSSb8&E7xmRumu8D)lVUc
zW>6tqV%kpzq>6$3;t;M9!3_QnTje0I(N@bKq5t9ABUJxb#DYaF(^;)yCO|-XB$x^l
z=T*v0JPHBxFG`VQ-$5o27x4JvXFpIKao9Mh9e3%{!Hye0ZVi-DotA62ZXJf(fxbKB
zCp>=`))AM6lnxUn<>3Lc11x;92$dl?8RFD}o{k@_1<kr~)AY&V*3g2E;nviGT)sB6
zpo0<&o0Xur3fJh@z77;;xQ11lVun?kI*=~oiy2u)KQqJ(Abkh}f>Wfg0}A9w{|D61
zd3n@dfV0govVi1QKO=6j<b-_n9slsoH-7r(xB^rIKdo0WZ8ahN?ElAi(0^j?-#_-y
zhyUAW|L7Bck8Tss%nWr7%gj*M!@6SoVcA-+Fh!}qsP?V6_DF9tN0*3p`Z-k(B%Z8c
zz)}pvJLe`0Pz&V_{d*%V%ZQRF*Cl0wnKZdmr)XEiWIsLp<ltcONVPp?zmaOyn`OF<
zTGgPMgOG4;r$LUDn7F<V(Ua293fI5OXG6Ci&RUEp2)s-&HE!O0-Hhbg6!u1f1nt;x
zq=E0VUu!}F2B-}O_&FJ$_c^*WP;Ydjh6BB=CP&w0e2y;5=w}8;w~3Yg8b-JM)3;&#
zU00IFMLR!<Uq(U@@r(I4v_~^ph<V^wJc?gM?XHseh0iwO7oPd}Rk{YTJ-xF+7QQOF
z;(>BdPvAe2OYjasQGjd9L^*UI#JITcK7AG*YaQYidM`t7`y~CNVc3|?Ra1w!ny(EV
z0`AqGDIePJs9*aSCtabe($pbXWfbFNl|IJFGP)iE;~a%?{TW7pas3{~N8{lFI|O|q
z+A?&(sJ@&{Tv%gP8gEjo%2a>-0J0#{M4fmR@w`GYHFaa?ti)I#E4W*juL_loX$p8O
zog*+{;p*p?nIF~;5^B6aNT|M`0_5X9Q>(4C<?sYfuT9eUCcM#DNa1K;p;T2vEQGj^
zU||OLCKje-SGLq-^=lsseI+P@g{;!VLS4qkLRm&XGq4a~8Kl*YfLlbI1s)S6%|Lci
z)9u%Q14ggakG>7~_lE7ndEvYJfw6(RL}8c4u`axgZ;7{#Z|Nz#P4qDFe7psKBX|qZ
zt?`!Lhip<tnvh{kYYo=b7*=4xv*71Gr0zf;n6nV(KG?XESr22hIDzwIt(o`G+e$A4
z(cQNN;pYJ2!)`<;Vl)Y9{l)ZPiS_YE85fX*L$eUGj{FJhR$O3F2V=$pkyG4>=eA0s
z-9pu}#iTo!c_$m}yN4rC!netAc9FtuD&b7=HkELuc$-SNPUrTO@U2q32^9|X$2d@G
zK+-@4Kr>^QTS7KP+h1J{L64%f3$Y^Czrgh`GJirA1A`H)1dyl63{E7iWfWo<-iNZS
z;?s5zpLXF^V4MR}^60(rwbR?ob?I!P?=TOf$Tl#)glY6(Lj&%B!G?@9`hX3^C^o<C
z)967xeH=z$aBnkjbe2kkTdsRB3~o&nzQMgEQS`C@Z%k?{ZkzsJBE0M8G`#7_8pcb*
zWdNBVv)d&XA6d@4L8&)jG|0ak0du+%`=No<a5t(I8ZNQOyit1pn5wNEyLS4av>5d>
zdcNH43pM4Xy4JE!E`-r}Jr?uQ45`P=Jef95<9RFvE;isI!-*m%A+yHEnC~=*&L*PS
z=J*tkK99U|@<Qi@*}=nO@Gi<~pqs#cP^%cA-^CEqjx!psRKU#p$hJ`<RGnE$x?}d!
zAqWTHA7yFzY35C#4k*9j;^!l%Hd(ayvvw|Mi8IOx#RMguPVX;*3nhWTxpOD85FIoi
z8>I~XGrzj)omqyWF{UKAH9K+4zKfQ&Gk^Zxtb=!Si>6TzT)M{vBKW)>hG$VdLQA3E
ziNr?vieKK0Bq$U@#Up_m@(0iZt&QGAWiYgf?xeaIYNNN|*0hPxt%x={D~A$jqut7x
zejU+9S*2+cu}V`L)ny{usD5T@qa??E4I_|dTF30?FoZ&%Gy_mwSmZjuBFx(`bOG!}
zNP_rRXBjCML?0jzvo4rrv>Bn?IM8X{dZF^T-<93NowT5qFVkwzD5Hhpc=-rAO9r)p
zTI3@)Bd=T{;13|pLlp$=9poSUKYNt{?(SW7_dwg(dn&uv9dYr8cS5~Gn#W#OoMPvI
z$s?r)qydjlzKgkZ`>+uj)ShH{I05z|6H>7Z1f!AhfrCXGcjN{j|FOLoHMAI9a!hh%
zr@NPAk@1&|B)F>u)|+Uem-NDcBuZZZ4`3-*-F{i#BGE*TG*SAxdXn>>jAB3|nU9eR
z9AY@aO`Zb3kyIloj&uYTa?HkdA*9>1J6s+cNxMTXEkzZ;!*~bSKk!c%l2Lw!XQ{F~
z*fJiu$>A83Jd(SNe5j@(b(^(rDvyFPrtsw;x~5YIereFb4t4kU+RFx0DKPe|GcWGV
z#sHL%F#~Gid!=IPd=M*UxiXPUUumigWn?Z7vjPqh3-Nn}Z{EU=08UA!Y`NkV0hf+U
zZ5g62i+B*xPLM<H*DquN)|!HuKx`&IM^QOfa$e{a0+Nanr%TV2RXWNioG!pQ8<&NU
zkcnsCP|ws82D&(5P@ZAekOiympvt501^UHGj?CL+(usbSSyp)|9FFW=>3^bLRz+5f
z>61N<>u?$9hOz_L3Ih6APA)f0NCHEu!UHawk@gWKWahQRCVU4V#paP9>cgCH+@FnO
zG5UyY3lrXuU-Z7x?L}W&GV`DkOX!B01LiBK{fB_tV+1wegm8CUXI4Q9sX?G`x55^L
z4C#Uer4``L(aP8!vs>M`4;B9{J$%3t;y)TrZ8_=lf{|X?ip80?$(x^!pCEJxKWivr
za&9Dn=@@QJ5##c;;dVp12WQG(W%;H7t?_9`uYT=|80oZSm8OVcm8OW%Wqc7M%jjo@
zi0SJv0>yiqVPr9K9qB^<4aHmc)mOZqiv9;i_BQ?JM4Lu7r^Pg~IW4A<t%v0s*;@^Z
zNbe|;rhSX6Bg+O!>t{e-U_F^jlo50hII;CHpNFPDWaM8Nkr*2+K&!0qQ3q~DV0@R#
z%3TJ`Y;-J5LH!W0q-1nOWZo;;flNLUF4M5aPz&p^^a4hsJ790<f3Sd2;$y!84}s>U
z=d*8t2fzc|p<lxYG`D^a<6jcy+NQrVv#AVhft(1jh0iHD3?m1~N$iO0^$XHJl#t#%
ztks|!4sK`KK8ANMdB<=JzG`^pp!gUrz8ESGQ-P%;E~#8ZNxF#QY1SlZ1!e*>xME1q
zNwH7rKi3|?ZuSC}5^^+Oj1OH(-|T=3U1882cySv74*p*jatHCnaB7H}3lW~F$U3(;
zhMZt#6eEL#wcyr8X;gv2FK$B}NV5VOEvyIMd>_;xhH=KNjFvAciV*4an8J@1Avtcj
z5Q>mvxHYU47q_Mep~Y{C5I8Q-&p?C(NTQtv`n4}Yq#uJ-nj(Z%nj%D(@kNL%qo0K$
zL=W=(_sE??`a7tAfcrftM&T4HL8So#K{bV5t9Mk-{D{(vsl#Pcz<yY(z+bRwd<cb~
zAMU3Tm-$iuLo#GCYIrO01HG2XKco|%BgRU9=QC*3B^MAql`B@?%#LF;&~J?_S=>dk
zWQB4U1*^@G5N;x{i(3PMxxCawU@k8;5g4QbKCu~rcUP=Zxt1&CFUbnsPZ{z*T$t8d
z_-nQqRRJs*jmA3F?)>XuPaK_qEvOg_!LC)9FJmLN!kj>Rrq*PzKB*pu4jSl8U6>Qq
zo>Nl)*o-+^KI+##>+@Bv2<zL;uciuD@>#uvk%n8y>c5$YtR>qND~zV_5O?U)u^jLb
zmBER9$F|B5btD6&n1mS$yT5nDn=hlP1=P)8cc!kWAx5-0YKX*Vu;(yph};TlCo)#}
z6Uqiv(L$&#R8E8(hE_VVNk1}`Qfdd*9?O-JD*6{h38A*cGhZVQ)saUj{s~~=!si=#
zSstb;Amh$~QqZq}PPbB^gBw0&NCAIoA_;0b;arzdzP^Tcx|M?d4a!6aBT9)?#Z27^
zSJBF~#ZnDGyb@v_I%bb}C9E=XMy&x*9qh_7NdLaEyHqrr#FdA-#Kwd}A``MLtWbvL
z;bQY#I^ED6nq<^C;I5JXz;&6(yk6R7K*CdFT-}-A&VbNE;E5?AtJ#vCAXJ&)mU3{|
z;MGtNuZ3cZ356G=1UDGl!jBA|#OY+QGY|Vd98`dUE`f5)J_Z~>Nek`a?kM$RyvM2s
z{?VOk^j><97|4|g-Lm(YcZId8dJm2OE*AR1JQOth<J})*{12dM>5dX8P~~NZ_NxJ*
z?<EoT4d3D;e!{_#6y?W9cJi_8%Q30)>DYD@M(nCTx#_O;PtH;Bi3hAe{sPIO<`f2v
zXA!O!S(V$hO_d7pxN4Is8r}ZtCzq*fnYU=o&WUJtxQl3Zj*`zoHrDQ@R#8nhnnZVj
zO}qjIrL)iawu#qkQnnLayc_qCi&CstKvGJ#XiySp&&Zt-LVP;i!1N%IfM;Q+%NU}J
z&`FQ5e)Alx7ez`8k9(nl`2R}zhcvPiW2jOt#KrO?F2s$?g}4KJh=sU=ynjH9fk?Oz
z7tu;C#2x0-C4^>hcQ?a9T!@RPBNyWC;m>Udo2X8qRoS3+A#+*A39=r3vu_>?aM5G6
zB?O(y2S865E~t%jIqqnWg|H)72#dnU_>W$Wn{hMl2o}N~AnO`drQwJl>QNe7Q?MWc
zUGNL2Wwav*9i{bRUX)Mi<+v%voh6$d>`~8vss|BPxnCxi<EF4QWdQZSc*NSV8D|zh
zScjX#&jBvSjd2~Wiyth&g&21clYqI-6}ym${&HNooeMzZFUOUv4h)>jaf5*A-Hca;
zu86xB5e@Zm#!pR4j?qrjk~^U$X0t-BLyi7>U+<8~c&yZPMzB)T8Q~Z5Ra9BXe;Deh
z#L9WKGhcrP6;Sn)F(^OR5)#?mdIN9{m)Bwi9`_yjLXSm|NuLd97C@(kpGOMGBbfl6
zMPy7OvIr6ZO0Gx5k6Mo?Lo+ddJ>me@Bf^39K@c$(H-_sGhp-+Ik`(D;Tm+fqBFI6#
z9x>?-aS>$FO>+?>T!BR7L}U?U0(*|gM)e}dK}j%vql0WT<_>;P2B`+aM$>3?kd4N;
z2r|h<kg=dq8G}Z;D;GhcTO<v5Z?p}83<#zJCgmbXnGT_OorDll64esO1XCqmAbFkC
zu##L0nWS|67I|K_$681Rfn8MaJVrD@$AR8QWhbemZPIrH9>YpegZf<D8q|jnb%gpb
zjtKR!|GoSuNwo}2zxHV_$z@=y(xg3BY0{o9<CC5&qo0M82S*^rmNeEvs%R~eW&1k7
zfDrpV!2e+^CxANsc!;V8szFO9rojpA%T=HWlU4C_2t>unL?U2J3tjaR+O*}u=M1V;
z7>IA-P)uYVpe~$MyC-2WZn)Exbi4F*9s=XC-}68^lFQmnIs%-04I8?*UW41$@jhvI
z_l{(^sDMk_2Yha>IJf5MgWWvc#ghm}M;0~MuV!^fEFA*39+0dKHwc?343n&GK(ac#
zg@J{a2Cs{iMzNvR2f^dw+*6Bo4kbbh@W&=wF?G?wu3LN}<ZfFfC-W+zr8|HC2o}zw
zLawAqyXk-nQfja#dbc)wcsn~cZruiTaX_k`s7-D~H2~#QB{B?@rm!Ol1NsAG!2YQ*
zxI3ovH3mw*2BkHrwyxr5F!5acAbffdG&QJ0Qs_{O;>(8xzeKd>->FUm6io2|NS-H&
zP6AqP#7c`&J*Iz$a6+dC33ot6W__ew$Q!9~4Uoq_9Tf-p0s|(G&p~P$JpLGNO$`g3
zj_`Q&-pm&WNN>Pj>MLLSJbpke^&N=tcvflhcwME><7FBBEadUX_EDR-z|W9*D}^0h
z4SgM3KxTa(8_;c!KRh6(fu0;<xWr#8TA%M)8lQ-grS02W<nG<d7M?{&6B>o4OW0ym
zK@yl=wTYoG6%aDza(28wGNyGls82CCces?1!eSUAnWd3K%6-8>Qo~Fq1<{i<s9P<&
z@NU3k@@k3MNSEYSsBwrDhtbI-vteY7DDT&p^s|5lhLup#SwP!Wo3*+t2A!b2{c0;B
z2i@Tv>_)m}V{ir~^};t8MlwSOf{v-8=)5GKL`Xh~DETC!<df(kAH0sF+Yr8+?URI0
zKJv9sJ_$uWi7xU%2aH{|56USE9O$x)erAvlCh-uH;UbbNLH?$Y2h*iRS6>Gl&{Y2i
z+|PLn@{6_^Mi%p;^NTQHk^CY#$$oy(Ruk6G{s;L*+w>ncQCEIZqAR~B(Uo5$hvnxN
zJr%>+ot7EP#k57!zIHGzPpxP8ZM&Y~9wtOzJ>dZ#?zd<7f#|yAKvmJU1BCp=swi-w
zP_uyew&0gEloXn-R4Je<%P-*V)}||jA73K1MrtAQD_&!XvHUdic8!5hMN)E=h}14|
z7l}<s$#@e=XifSUNG;+miKqgQ!4Xve3HT9JfT~t6Z;58f`gKGVV3kpCNmLckWqeIq
zvS9rzstQOW*4#M*ec5cp_I11g2KIZrUy5d(#C>I1V<7RUTS>;Vh>}eIhOw-PF$rKG
zLJ}5K+8`uB6vHza^&*}jRwh5pyhCG`TG$T7(w1S;5W8#@c!Z+auXWvlo!0Ml-SmPF
zj!|!x6soP!FbIi+8Lel=so?Z$ya9Igd%RDr<b3C@<m|z>zB44}uU;7&!crqHH`0gj
zaZ}`&HrE`Q&|p6$V88>h+qwCR`Ja06m~}fY;vHmP{IE2<krILjb_dq3e4zeicyAeQ
z;M5)NfO;bLC>mxu@*r80%%Z8|M+?5YnXYRF=_2{UcjB$-Lb?t2rVUKr0qoAe2!8W$
zbd|CH-WPo`If#{-qK}oDR<K{lmwmF3|1cDO3PzgsOD|xsKo)lf(-&ai33%{MAuMbo
zYl|B*%VnNCm}0;=LC}~0=QW)Q%h?gghH=ZnVHd)NH)8}o!Q%pMxzl5#@}m*BHX%8f
z<^p?s1nvN?FTy$J?kF>OC2aJOg)#bKGJe=;4->vm+^3<JVkOwEIpgjL0#MnJ=V$jm
zdS7=;xAYA77?~`Npztuf9f%QUu@tW)PiVx((C*&D?&zsU@6DpFmkgs**f%)yV`ME@
z)Ef5D9St60Trmc*(^@PdP2?to%4Oe~Gja^I%TZ?DFYyjpW+!m^1w&DC`%a_Wlvyqp
zl>6zR9AR?Iehx;Pd06!cJ5-P2R>>Bby2i+>jM4dDzN^=lz+|%|d}}zj1fh(3v0l<S
zfe9ZVOfx^uvhcgz3z`__`m8kOMrK#@3wMNcm&87kT)d3zLU_G~rTUajAnhMR>^Hsq
z{?L<0FPJV!>AsPEAf|O%y-%?HApJfMCD5>*l%XIFfqa-a;>VJYBM_a|%O?@upyL$L
zZHBqw-9#KCEe$5(tw7K&hB!v%-4e->9LH}!HCRyid<N~9W;2A$QbiUCkVT>=Sum|`
z5P#rlvUoNjnHP$K9+1)385`zXlm{u1Sef{mAg9}d*OE72`3-!m^Wc5>9qDGK>YmPF
zWC)HpgGjvVH(`BqBp@t=rhQxtg$E!9wcp@fL)e%V5KCo8)T$!(xnv>9R&5ppM=}K|
zO5GynOIY13`5*W#)ZrCGX`aLJV^D7L7NJ|q{3!VzcX-1-fMQ-K*zh|P3Qkr+@-NqF
zm?tYG9h+4#Y-V(j2mGOfnM>Y5+U;DfoYb9)f%WO$!nv>ZLg+8+_{@bTtDl_f=Pum5
zOiqIY4;ODeB;@L?dEf-H$+G(}r)nM8{`(+%Gw#0cJ&a7VeeV9d#zr{jG!y#^#lO1n
zF!~9_KfGY`<JJis83TGp)0VaHm1jVJvr$(XVbZNU<r2q3@M;i_BF1UCz=veUE0^0N
zj6!>W<}pkuKP=BAcid5MNCG^}Y#Q{9)&9=H8$vMr;$zk=0qglT6oWtfoimgmNV1(o
zzYBJVxeA+hin$7#c8cka_oa#-CfUMH=`+~}fs*Zp_B?b#2C$^9WdyMNG58UzEynN`
zTL^#GB4jNIZMj<5&Mxx~sou+Fd=nr^ZCBn9UB;J<F5|;l)DgQ9d!R(@N@gVuhGykM
zqgtBlWqkUzPgA1w-u<^&Z2W6~_tWo77A-dZ$ftk$eSh&cKlF?4jK#*k_NCu>!*71{
zi$DKOY$VOr|M9W+|MlyB<c~k`H@Ii(U;oq3z3=t!f7dVnCGK_g*XoU=(UqJ1XQ2l1
z7SR(V5)Q{hINXT34g30P+!`qwIJGtc2W<EffddvYnFmq*Xb1;%Nxuxc6vKR^-#!o~
z`j{*8loA$QU8Rj@xv1VhH4aK(_ewn{*!>=F<VpeVBm-R&+un0MfZRO~i&J1-bF)OL
zj$%;?7Ea-{{8G3U4|TAWpRhkG_CDeRr~fPV`Z<ii_;?bA;l~L|7V<0mIyr%L_#})<
z`l9=TV*#_>W*B<`Ny%&Fa!`ZU>ZOoAtL?o!vcJ<1$iZ#;@4C^=NVss;6oVX=DF*eh
zd@0y_SY6ywuU7(lz-0C7*uG!!8G_s`8oPXwm4@81t4lhZ35!;CDToZ-7>x{G&Cp-C
zis3MBO$RAXZR=v-36p_;*6)&x=P@H`yDr7Gn3ds`<FGKaY`u}I8bY7#)m%AYb}72B
z0;Wk<m*QrZzUX&Ju7%)QlI^-=>n=%V(XVqYzv6dE;u1Miq)Q)&u4uGWmyjy=A!;He
z`&NW~oy@<NH;{;>R0(eN%uh%+BGwSAHxRV&yI}F43K&X<3d9^A!mwa&C^kmKTZk`i
zsU|Oe`CoCtS0CdAx5Ro6PO+0aa`7n*67I$2Uw=(qOOr)P*CM^r_~@fw!iqxdn}thM
z&mGy|Q}L6x1X!`9aL@`T+=@=P6`gRa3kUJqNK|8e0HD7w)Iaal%9N!N)%0s$nX;(u
z9L9cNri*?b?oAiHF5`RXWf}b}B(Ud)3Q{IG0#dHb#*AVY&G#uq0Xt|yQ9%3yn`ho^
z@d{wMm6jei2~v}reygEvp)#L;s5AgLFtS*c#ofKQaf^L>7JC7)8tI$D#z1n3Y!*|;
zZGX8%1U?b`ge{=7E4Y_Dy7Yc_$v$C22T~h*UZXbl#N8+(p-#{v*G|7#MD_^v!#RQ#
za@A=p^V30fF@zDM|41Hkgf08&f5L}y<S`%~-e-P>D0{OtL=a%d5cLzokKC&b4tI=A
zy^g_IjS>KoaujJO{hgg~WSmLh{Ia+oYvP_eKHaL$QBC`Rf<6X>iqr~qIdE=ZhMwA`
zFIZgGYcsyXFSsWgBTi~vGGIBDU_8m1w`ZK&c*WB?IU;O`4Q!@+5GR9kHHS?z9VcbN
zsz>kwpu`qzvMIU30B(7V%w}pVOY`sz<Z!ci8pW9s&Fdj|kUzs}Zs;$Qhf$8GvR_wa
z+1oFxvZE-A{RXjFO3}UxKch3wo%k6+U-5%f))V+ibM+gb%SA(o0~8VKu(%}7#ZQ8(
z-z;~C=QmsKFqZhRHta!3&;;A8r2pAYFsdi8|G9`l+-Kez;^=XhMesohd%Xkxn9V`S
zfvKzluwcTT+esR*XQo03dzsG~!k&vQ2|X<I)36@^0N`eU=#Y!E73@VY)xbXqL&7f}
z!ai=o9#iLRg1y|uJcNC`q+!qAcEcV>d?DBa%!EBol_Ts26zp+Yb`RJC^)Xil?B5gR
z2?<36IyH#HQ&b4JNYaO&&Ln;MSMiFZPZw<#_{~+4DL@9?Ax7@N3F0R)NO^LH4+Z25
zS2nl(#n~GKAnrzqsdR?xPQ=p-5$>1Vx^pgfAxyIVe;?GJ^y`=B1mbR#OXibd{UUvT
zr2dqye-pM53|K;ie~}f8e^aFWp9vaD(I=k-y<-lPl?TI)V^a6P7qDdBB?<jh(1G+T
zBh7E-ePB?T4+qVF{l#P>WOZ^v4E`3dLe(yBWxF`>O>PvR%uCLf8f1DSY}@U{+CCDr
zOJ=6`27ou6<|%3cPE%Mb?k{iTB3gAHj#$&W>$iG7(&~2P{b<lW37Y%ZgL9*OrW%>;
z6Ti&%HAB!4*Z3Z^|I;Eg>^Bd4XgTvyHj6>_;OIl>f}&h_Psbd|xJv_C)L>>6|2`;r
z2s!W(c_nbQUowBSYh^Fd#8m-`#p}s=SwtxMa>vemg1yUv9U};jdet%lwUdN>LJDZ~
z5nh9s+BF-zN9}wi2c+wMMK}de0(v9eulT^1991D+$;Oz0#u~K{jwx{`PW4D4B=>kx
zdvk(mQRJedAbh}5H+@^AX`!CVCMefMDR;9qil5QI!jQ<E`5}sQI%<N7UKD{(P?3um
z4AEq8Eo-Y%u8=4?xN@qLYjxKisS=oBdgnCE0abR*R=Q+h58vq8QC%{!$0$^#E?qLZ
zOA@Er&?SG*(z;}CO&uTSe2ys6ACGoZ>u~6%KsO!L&0w>L8(ka#WZF296NsR$b#*g(
z0ueQ}Uft|%2@=j~)-n0)ir?vU7i5jul9TSzcnw^hH^MlGboq(6`U1#G@8c#{A2H5{
ztd)L$6tV^a5UKi#0bklN2Bbf*WiMqXgYnP;dMf+;v1mVyNk{Szx(cHsHYRC4m;v-y
zC<N{gHUv=ajSag!e%CL+&wn)tFyaWgDChbGVEpZZy+3Q40tRv|5gHhjS5NFeNGNEL
zBiC3*h3&-RiDYVEFg-LpGMd@5ci;X4mtB7FibIEwTzS>g+_CJ{Qt;Wg2yBfH^_C=a
zT#SsSOG*5t@HdFR4F2}vZ$JJn!`~J7JA}W(_&b8XEAjU<{JHqc;_qtwU4y?H@plvc
zCh(WT-z5Hu_?yAsEdFlB-!1riI{u!4zh~j^F}S%)zrlZglmC2%|NLj9aD&~Xf7dYP
z5jN38U&7lEV0!SWnBzDxOJJj?Qc@;>mty!qHGSm)zn2MuV7-Drt{jLV7VPvOcva><
zQXfjc*BGARKT+laBp$T&U+@(tn&?Vf*MXmG)EmK&4|I5lO6WL*4$4cF9m1w0<YriS
zqSPu=hlg54e-}E1&*gGbis_7IqC4s0FFwUxe8^D20YxomwM#4WOF{2oc1S@1F{Y1;
z;OP`{2Q$D2FmeDizEj`n6UD{|ETw5nZ6t&eD2H$}{9!xMgn!xZkDQ}RrU{=h`AZiJ
zh)4e^(kws$T=ErgJ!Vq@_Xpoo0XIhc8UZC2V57?qh^DT3?5N8ZKq~bWF3nAJB_P7R
zpK-E+0L_A-;V4(^9uCH4+uX1YZ5+&ejN_m)mN#$ZO*;K{J3PtUL;#H2IIw_JC3`4J
zW1M1tzeji$o-av+?mz7LC{M2u%ET%;a9fiy)Q)m-=E9;L>~9O#4U9yIE}2Kz4SB`@
z68wC~Vb8#^7>2Eyb>WF2`e1Cp8DJDD!s3<8n`nuE-hfN!-r>v}c^{%1K8!1~kUfyb
zi);YhS4lg%U-SjUnS5hR&7W-rl_3okHVLO<$Vu7T?O`ML_v-;0<Wb4OuBM&MFnVt<
z7|Fe}<+nt^%ufa1F!POrQ65;iF9F9-&!(IUZpyIvJ&zKKGo{O)1Be1VVbA19F$pk?
zhtwpH_E8HaJvs@go|DiEzz-)y(oetmGNh9>oj99C`|UiR7{BtIVgwc*;yn(u$ow1!
zi7tVie=L`c(G+k>pUjaoG9TwVvR{7q^N|nZkq`fa`QfJ`AIdb*phop!=9BycK46Eg
z>O5VZ<(n-Rx9H(P+{)9R9O5Q6yyFiyvctPi%2C`RKIZrSEyT}5nV*&QG0y-FVmFS;
zIEv5WTJA^S&|xVt9Z%scWmWv(kMMz0`c!T?8@t{@N(Z0)g?#pYJj22!xu>J-z${*&
zuNC~DJ0H>g_z-^K{siP^tQYd~n0O>t6jglnA%INxPC7N@Xde(rPt(2o7c?Z#4RK2U
zGwdCl#(wX92p@<2dMEB8Jz7#ddW$GI@P|7kM^7q@)Lz|t71yWf{=Jnc7hwlsCL^Hr
z2%=Q<g_a&c&wrf&Ws1imxiM}^j;r_QvhpOJ0UTgG#tMKGCDFpTQe(DrLPbyF>bc%r
zMdB0>vxINb%Dh$b5}f{u^NVf~UjXPB1N%Hdh?Kq0@)tbm)A%I>9@D>{;x9n{v7F?~
z@JM6pF&y;rfMBXEtngdJ&+rqX=)2j1Bs#cpsBXZShQwR-wv^KwKB#sGBQjXbJpose
z)JH-^1}!>ri{RXvKoX_SGQEUI_jgJUV;7hKiA3~DgSglg`0XAJ8!3I+w^h^cj$yaN
z;OtYLgb}zkd~QdU@L&!jg7*6W=unPNfW2URVB*2hxXG;qgeW~Ei4?oO$|4FHV9O%_
zfOO6}m`|N}%!F%jcntU!F@&DN5BO%nDvMlU3%re9Z={sRR5OqSaLM@40w<S}0>KXS
zkUXD9kP@tsk3eV;ClaE!U<6DTmo8zsf2*WA<qd<ZbZ7(<x;j#Q6EMMWi5$hPVW1ts
ztr<Mu&(}uaQjI4FT)x593b0=2tY7<qOX=HrCffenuZml+OO7-D)z5tH-5>bqkALbP
z!2qUk|HyBC{D1%4N8j}cn2PM!H^2V5*Zlf7-~HyV;5B>pjo(EI*n?mCd8UA|Yv1_H
zU%u+kKl`Omd=2;P+FyS0*Z%j<ee+A7{BzvvwkLIpm~2}=3j?4(E9`iP93kK4G{Oxl
z#RYM~wZDt#L8vpc9ut?9YgDk-Ifj^<xE`~E(2i3|wBXB6ESGNZXE4EV73B+dU{TCP
ziv0%}mIe~htp)TY&V!F=o}@5Aiy0f}4a||`<}2bqjQsORw_|F4(QSCJ#}Z%~3Y8J*
zL&qh~g5g88QLUo?=&i(hZX+``2o{2^CMgfGoeViX6kT>qrQ~Lj{%&!>f<SzM$OjbE
z<3o!$Rs-LGmIsM@{HAC_!uiA0RiJtF1oSJrB=DJnCAY}S4sz$E6k&<VBrNF(1}sw%
zSYn$c1xqZ&*b<f)0AYz812F&}5VCQ!36_QV6PnZ{E$M+!pU@;oD3a9t+Z;orh&PfM
zXw@p*#5w&wA+=t`7Xn;i!+M0={271`6i3BH@X}vlK(!W3M{AyvjJ4)TH$S!0sOBm6
z+NQ>HkjHhA)<b0oeU||#pbNUoZj%S3-y{HvO<goP30#owZ4vF2&0cXJ0?C1>O(|Sj
zD>nOv=?;5C3#nA3k`|Pq@)fY8^s~_$g`pZh17NWq5?HT#z{UJgxkuH^StQHkZAra(
zJax#8-_1Hw*43yMYStj;=cu~GvsZ`D)Mc8}M<c|#HT`S0NWsd%0PNBzDGDmO8YeDK
zVK>bzEDbUasm|f0ix4~L3xXC?N#zK;Yc7M~JER#<K7<Fz0)cxshTR5B_nyw;I7FDA
zr~<fvWpSvJ3Ln;?+=jWpEtZ&;4xWar#Im{5*+H5%u+6a7H=hFW0Ylj&!<P0L(z%5b
z*kYX)Nt%1~k5M?GYG@2-9oU1didZ}1yJG@<1xG`f-d~f1(Id9*qNCCZ;P(F*ppAjc
zkqSLh@Bp?I9jTT6NL+(Z4ia5D<=S_k1|S+n?gF)!rMVOUSSs={43?{yz!?B!Y;2wc
zgrtVca$F*qLgO)9WWmdH4^r|u1{4dyoWS0C1RSb}p$c%_Wx!nl8FO<R7#(gq;Cd3s
za!Ll}x<xdel0bG8klA3IiyFX?T&JTTjcmI!8q!?r2u{Q)hU&oZvzkIzEX(@B;vu}v
zGME?%q5u#o@QZFJOmh^bIRrl?j8GsjMi2OtnN!m;G0pKoAOS5g&FKOHcBb461dVB%
zfq?P*m_|tSz%)*P#54&6gsZp3G(BC!eP9}PAt9!@z%x*Zk7pQf6wi!tN^rAu7F+0Z
zC?pRe7Yd!Ct>+Li1SUWuOjs44hX`Y(e^wx>8=Z#j2_BV#=#?4NgT#r)St2^XZY!!&
z9*$SN`oYwSROi7ANPGs30(pq`@Px8dH@R(Y%Sw*`B}h@3N69(E+Yd)?KO%3}MB;vY
z?#zD+{~LV`^;-WjaX<ELbFi^)7Mq*g4?e<oxEr|t-fVo{eI1U}Qn7k$T75rWCSLL=
zo+6{sedxh^u}xy~C6C@qsNYWpasRzI&OMd3Ui%UIx>|E}y}9PCb;djA*1en8Ti%(5
zcQ!v>saMuJUTeJNRcf7P%drk_^~$QWSBEWOCI63~u@QC=r8~rYT(s<D+p9I#>g}`X
zwaQvk-<*qCsd}a3bsDRlV_D(^{$iH1);tS0u{GH8+Rc@XPNTU7x4F3CY^B|}xwg`*
zooXLHTUl8dm)9q96NQP~c&j#E$Q35X^SSZ-Y}^v_Db&5*Tv@49S3F0EB}=Rev3^dR
z5O!nDw&02$;Op^~M!O?o>ah@(E;SA)h`1wM*=VDAoZt3r3SF~A(2|%Rv>lth4<2z~
zXJb~fvDWTX);f-5bDU^jjx!b=XG}DNIAO=mE_rKCs#28z@XlLtbho`xZP!|jswWbT
z00cs4tTxx0o#tAjwhc%e^fQDu;KP2R^~eOYoWYGwZM?a-*!DWFh^<vtz4qmewefo8
z+)Cr*QfItfIn!7>InD_?AG0$2eFZ=@UT?J5S1RY^;DqeG;1HAgxdgC&{0fXXY=l5Q
zW{$<LvL~?PVt%{_d}CJJYqfxvLNsh~+CH#SX?Mn(>t3ru>=|FIG*-O2aI6GSrtQ@&
zO!H8?18iO$R|PFVVyLmUzJVdi=ME5YxVh0WpNJ()ortx)mBp0Rj#*c}Y}M;5HR~^z
zbxd@c<8`mPagsFvNMb-NCB*uDVp*g`oRi9egU*V#b{0FoTUYp{&1NUir@9!9S=pX%
ztHgdzfcgwopWRgT$W~RiPc_!X=mo1*pGiDaV;!_IG3%<H{RvTWk623jz}ah|4`Y6T
z2oNV~OJ42N_}NyY<B5G@*$TVAHw6aK0q<$2t^G0UaPRV}<bjwq(ffS>A^G8WWvxEG
zxU$h+5(mQGZC$(i^s<<B^a8c(55qbEqNnvP6T;|n9|`s<BtSocX^uikb^aAztLe4H
z!I(AOyXvmNs_%_49~6y*IN?ad+v~JjwJTJ^n4TlOYXlWHYMwY0v##m=LC~cCWjH3*
z&zTR%B08qUX6tOFRTqaHakbA?6|J><(s}|6D;A+iK8VsJpD5B7^ACU%+alRb$Cky%
zkOt9`;8c7*5U>slKB;bom>}a$ErNNp8?S(bN{Q7}a%1fj1k~D)gaj!53;>p?Emc|&
zjS!LQ!9cyy@+d0L#TFZj&EfXB)oK%<g}7NeHPrG>Zmd*V<E%N+21$FJm^E7W$lljc
zNJ?MF8Wd}Z7%4q2@nIi7A8&w0PJ(>SjknLO)%HPrR=S?;Z+WLTymrT{D>{=OW>z;k
zkhEabe!r}Y(ct1r<zyRYF^e@Zg1)ks<BJe^O#onUz0z3%70E9~#9Ay-L#H}kIK~0*
zo*Ia(amGt^S{rLMyhJhZU$9<PEF&P!I24NG6o<o$LGK=~hJN7^^RU`Pha77!7<i&m
zt9k9V*k>iYdmy0O<k)HTPy=T_=VnlLwAS39T)j-3N{Ut@M%5*4ytzEa*&8?@LFLy0
z!3A-=x_<Dme2lgmiw$&~;({Vby}TShosIT5rg!b6XS|3`7r%0>E5vDMV6CY?hKL86
zSk^#Ln@D01!)xBzupY-c4BbfeSV>z}>`&1+m|+Vt^-8gNjfP12Y;$9!J}z-DSy>@O
z&y7?ob)cP(JhAFV`&_DyHxw4}(;LlBB`%>jA`z(5Y>or@PI?C#D=Xf~%F1~491x>T
zq*<$ZX^8vvR`Vp3uQslM(ya~Xes$<CXDTa=y4`3FHQELqtu&kKBdm0_vUX15cY6r%
zYgYg;0)CiU#JFs=xptBOQY4bXl^kFa7wqajXh<82n1u!v&{c00)U!A8ti4{Tp}uA(
zY##M>#=X_`&bd)u0lAxJAohV#=?zr3zTRx1^9eN3>6{zEPkW=b<oAG|E&|78mCzPe
z8y$QcTW_p;0|YI!z?E}gL2}@LkaudN<K5GdbURKk57k=DHh>|S0MJn?0^>CxvSU3>
ztR~QIYqhd6sDRsPR8|r#h@|G~z*zu)e9iOf19eC}c}0M<yp1+!AyKK5tvK)_wd^>0
z=(WzqF&O;BtbNcrKuDnbrAm8g9G%<1msg|t5DBQhT-Jq1fo3C?uAz8e7RQ9^v+wH?
zO6eQ0t~aDoSfNx*#?Le=x)yPRXgH|i#$Hw26tk}O#fMRal4?dB<G%d7&O(tu<{CvR
z7&An;QD%Zl1G*iPQZ49q0&3OC&eDK}T-G{ns6l3h0BqY6xv*t?7zjh-LvmN>y`754
zW0<g4!xDwwB~E(446-{hi4tkE#FU}W7;Ufwxs{j>ra|#4_C8R6i~`WgB~6K<FV?T?
z&DM@=$JUOp`krHEf5`mA3>DX=J$oJ_nd3;55^-GsW*=K_j#-!Ym}*iFyqwEWf{nse
zkhj;G4N&drG3#KD!V*u!GeqNBRPam_j?XgmN&_sCRs(DYZuIOEXB3mE74hq06l-mQ
z;@Td4P$DkmGvk#GJ!j&O*_~epL+>?u$^-H20BD8)9o4O}<e?tTvLu^&jyMrl2)?=S
z<DKz9KQ$mngpxDPM$18?BTWdIQ0$MU{QLF@<yTn2bt&ElknA-iDWXyPb4BAC0PwdY
z^(M9&oS`-BiA!o4R*Jzs>(g7nOzIhE;C9sB=JY5_%b(!SpjcqNgguuG&F|audm}*$
zGU$w<GbtqSS<g;^(u>kso|KB{^$P+t3G0gjHPEMx&igtVD)_E|7j8xssaYJ@irlp>
zggU;vH(hP4NdQT;0biB2X~~}?kkfb%yw(botVs&mb{m>jn*hBdW)-$B5m5E`=3>2O
zm5Ri88`?PR{e16H$xi}}m0tx`m;qsEUQ#PDDho`aUY|uO3~YPjO8^snGZ;|3*;(>h
z*I96+1je%QJ(R3AHK%5E8J2{&6WD#!WIn$Gymos4E}|WX7X|3G89OXi(MwQAs^A>G
zSS(#DPF;mA{1-{S$}#Z!mh}gyVKV4MRB_dsg3=tqd6YVzc&S*5BgO!s>Og7wf@S>?
zYC1stXrF`WqWv;bl@j0Yi0h@r7`{GEvDw>hgagis8>*0)PtvkWNA)Aiq6*Zs?Y3BV
z=#Ya0Xq58U?`Q*35WcCKx*LY$lMJVK+e2c054>J$UgvDHbqemN)dRl0IIO9y?yWVv
zy3{xW^)%zFm{7|%RskT|s_?>TB{)eAjVJrzAgOJ%z&mQ^0GYK#7?d5U_L@4oVId6r
z^-`>O8M10+Z9+|luDicduT#w*r{-L3tV!c+#D9o7p^NS%4}^KJu?8UvDu!ac7fr7L
zC21<PyhVIe&qN+UsF>eWs!|8vOJ(Y03of_70@)*(AghL-^9<`ggsF$hUIFo`hp?#W
zz1wJchsXdb(mCDzs!Q_**zH(j{mc~qDaNcljdggi)le5JtBn=dRE}uI?!*7+F2I-m
zd!UYJre3N4r(PDrmr2;BvSyL6WaT0Sv>goVcdP*#bhJ8Nnbd72pt8$0H0<?b$4ZM<
zOno{)D+FfzV)L9|DwS&2fN0~5I=tj8U-aiLC_fzZW=QvD1ij&CyIUIdovi9b`?$u?
zo{pDc5Kz*`VR-LJJ#g#zPw3C4lNyc{cz~5xyXL`ykvK0LN8}~V_)T?x(X-7_wrQA8
z@-_r3Z#U1Pn7@L3>vFbl>aKM3z&~eH?<j8%Xf-l-a5>pxZ*PQw2kA16cRoHC2Gt;a
z56cMi$9*#)ZNZBhu*Tjc!5WG91RktPJ+ETK@V%z3(U^72XR!X~`b(d|h91U@SaQUv
z0nr#lXZEo(F@M_jDE~r0-ii?R!sv$UrcMH{oB^Sc2+!01x~Ho#u)_m>*ddtO^>InT
zZ~>g!SnoNp`~0bkqNJF=jj+B*Z(VezrNb_Qm~#HQXIch2IG`SMA%itrO!$ykb&~KW
zcyMb$TV1Qisu0-l;Ix-EI(2vewId2W80^%1ngh>Y!Ylw8EZ9EUY}(^b!ro!%0Pwiz
z2~1o240mZ*$prXyOR;3J-$$rD{5Vi~jE@%^YYq4T$iV64R+d`W<cQ|rW}AWDU{s^p
z)QntQMkIuV-?T432wb{?gHcj{j|J~=ps*Mf=zjP$95y`S##gEtM%}zM0Y84PuIQTl
zk3=IQn$8i~kt@xPTxHn!MiZ2@>mBhl^gC^S?)GjiG9_ZH_u!&H6k{PYK<2%m;nS$1
zGm%AS&YPWqza}sYjJ``oPq!14J#EPBiAxvHdCq??XwilXi(S)I>@17j;Bye8B^FZ<
z9<Nqvr&gK>T)|x@uI-JIr#uf*bOpp9j`kigD>S~k#&BU6&BDo5_Yf*%ErCU9yk{-J
zH#8XUGof~!;U+Q)Z6Nl^kl#{sU8y#3ZAGDXAHfhXQllu_+g$v5G<?=<_y)s5G)im!
z0B0aQ8w!9oZVm5Vp99{34sO&;j?-Q3bz4m1rf;tmjX)6Xp>M4hs)b?$emG?_?};+E
zQ35USLz$h^EKp21;%G$L<D;H(-~i;npus1_{Lm&rEh9DE>|09jEm*Xa0EpHZ^&-YA
z8WhDT0kvLqiMzOkfX^Q7+X=@b1|3o89>%!-ObM=@gSuSI&vFz|xg>`XkxN@^AX~_#
zZ50u^=AdIzogVCB?vSU9=Swvk`XwN<Q8y*iF!cjSCLo6r6C=K48jVV(BxAmT;~}iX
zluUbk9yk&S5E~zxl4<YeCc8V&Y61plR1=j<K*@mL8Xt8@pS@yz2w1Q`j4zL*S1b3>
zs@PcRw9i@)J%P8%s76yL<X<GVJ~H5gwY}fE-0=DtMM;H%!ZI0Zfg{!xy~h+4I;KQ5
zYU~m^heCh@je7y1OXwU%XU?0QIbv`Eqn%KCT<LRy5nt$RH78)3VKI6J?lT*Dn!%@y
zhBh<Wz+I;sypKo_@M)uHZ$2H!;StVC;K((~^<uf%u2G(4qk)Vx3bWB(6+n0gJUjAv
z7thYdtbk`nzJnXTo4;ResQn`rq+`Id&5}V5&^6th7hm;cQU}3#hYUV&={PS?+o<;<
zIBz(h&77C-F3fokF{=!G5bh(HPXoI*L+_1>uE~gITSy}n0kaX~%|>yG$z<0`Zm+&R
zu6}v~@9^e!u3&92Y7x0^dA%FFyw@kXWtHrtTlTBz+4d1JPyPGsS=!ndAiO!cQA8r^
z$bb~%<|ra>dscWQveQr@;_B-b>qLxDy1cx#GmTbrjgBW_i}g0&A$e<<qwqaaZKQCW
zl5gUO#KYoXFmt?iw$5ZUKY^=p+^DK&7p~%%meKSHkpNpqY#q6RF)N1nbcZ7vlOw9F
zpe8)&S;f<|OQMJE82Tj!*!Om)-dLkUA{*2yAN8yj8I;n~(IZpD@OKRAdf|;@#VV17
z-9^QC*0biZi>evk&`mYtS<jlYVjgpdm^32SYnTq1N#+2IHwFWazUx`b)v}h+;7g1H
zS#PXHIX^kPu9rRQISNK|SyyMoyi{di3v|73lo#ogt&wdn0UNZUW-iuqAX`u2wdla*
z-Q&<bfZ@>nrn?LKy1T$hMjv`WVVl`L_5>Q_+;7?7R!DHYn2#aVAl^X&k{6d5h%tH+
zW5~8zQ^`>&<P~*bA*~?GX2m<>t#Ifk9Ca;{u-KW_&`#>KjW$Wrfk8-4sc0KFCy{q}
zT>ti*{~N^o{ZHJfBTf%Gm<TYuCB%^Nv)*ju&H+kVRsyD@*YPZieWni@SIu>LqLCq_
zAb?+lBWp|emGKqP#$XaEQIjI-v=h7SB`>)Xule)h=x1%DCo&Z|B~Hh{<W%0rMr#F?
z3~ML6N*Kk15oF19nziOi@FcSVKi)ceh0H6=R<kAB)~Tu1AiA;G@K)+=CTAo$I<Li?
zE9mT)J48P89ek?D!&X_IGLehlXMl_+n~{g&)H%^|d{4U!<Km<7)%G65QChHuWnPcp
zZ9G0$g^$)lQWjsd%>p0}oiv85SqV<$VJROV^1<5(LV+hB!)+DrtyhBoE7q+OU7$(t
zF}mEAC1n0=@U+^jpW~C!#f=W7W-wkn+hdH(C>uQW%O2EagG!;w>!wt)Li<XwewAnp
zLAE3rWI_bzX_gD;`OAPT$TZwwKHkgK6u^PAG$hsobvLWLqs*e&>l@kX%LyPOeKE>j
z(%&iN_-fKg_vcU<Mc{+cpYyu|UDYZ~7T5Ny`O01;R4$CT4&#&2^Q;9e`?9WT^}y->
z@V^2G_IG`SG-%|vUoVzM{m*W&AWs8-i~(bbffI^;#Enu1P!-=mze1p?Zz>_P2hKK-
zIfxos=fpVu(z;JKSQFbdrl?RLlpF+RH&tKRK;|{mAW?B+IIK8lm|L3)X_`X}wn00s
zKs7{y@&;>iyK=-I#O1`4SQ@4?@<d!Sl;mjFFmFnz&QA;k9lXgW^=S*Ss4FAL7$CW(
zKIGlNd)%PiHWzem)<Tj^;P~w>GNH0%ZV`?BqHzcXp8==m2^&lh<oa~vTq+`YCNb*D
zmyvKAwU_%(1G=6d+CEDxAw^k1<T1;FV<oW04N$83=m>!J#+-nl0AL>&rJD=*z@Ilt
z0P5S6@WK9Uv4l)!CanF2)EwoM{hyZgn;24HBn1tUU!ZpgSFVa%MdJ!K*I8<`3o?P^
zh!2A3_sV;K6q2PY4A<FbEbBj`ji8HN+-oBApuIpeM$o^{VcSn}>bHZbLk0ggDhOO?
z-4&3x+=<yT8R}&rzC45TZZa=p^3^nm7mB68E%3Wo%V^NmrjIqMAeetxCGY*05S+iS
zV);Q&gTfM=3dde5PGNv>6%w3tfzbMbRN(`_MoVhIexF!6A{v(iM1M>WEsHOq=~I6a
z0P2gD^``(-kOH_Bub13-!N(w!;`{`b`<A7`iMrcY+Lt<=^=+~UZiFs*WRuY4!){5*
zXIsi9zVs8+N2nZuXKtz$+8AGr_maZWbqH>`WeYl#31;al8gPILf#d_YfS1J}yiq4?
z#IYnFPx;!?0G)#gWHr}UJgi+76VhOiFbU>Qz3pvz<YM9~6j`NqaWl&vhsuKJJQSaM
z5ZI|Bi`EjQGOg#`wO_kyzx*X(ub{^$SYWoh_Uq-lYrmv0-(C9^EId>~dVF{7*Y4V{
z-L+r4Yrl5ae(CjKyKBF8*M9A;{bGXF?%J=H8_Ohi*M6<8UwE}&;Mp}G$K(du?{XDR
zd3Ws>Hu5l_!`z$QwO?wf^X}TOa61eGMS>+_yKBE*?k}4<r`GiQOB15pS-sm``-SCJ
zyKBF8*M9A;{gRut?XLaWUHgS#t&W2A$iI^@uxO6`?%FS`CHFcLW`_Ol+AjcPckLH<
z8PrS0cGrH%m2<mmztlFB;esb4b7gn!*Y4V{-L+p*nC`CqQma6B*M3p8+Fkp#-KyK&
zwO_kyzjoJtaX<RqwO`n9e|PN{j~#gO*M7z1N>(EccdK(5VnUR#T=1!0|M?Ui%&>cK
z!0y2T+;C|3;DFVMU>AS2CG&UI!2!-wvFZR0Y0Jh|;o*59d=NczfKSvS4O}_F!7KjJ
z1z1=gsX#l#v3+2)8q}hf+4?I!q&FOn^PoyDbj8L8yGIwu<$1eD7wjHguzPd?HelF2
zx<IZ9-95TMo?2yOGI8gN-J=WS**n;ib@%83e^Y|%dTbiLdvpOKtUVyJdvpQL)7U+_
zpoKH;<Y`f1O62a*1-nNV1ScD8v+2M9?84aQqYJQeknxavH(`PQr9QeK{ls@>8*(;T
zs@VO@ikT<daoZ3FXPgDcl_67@Pe$avb3(K;7WTVOV<StZ5W{2D7T9Oh;s%XrYAOE1
zz1;OhZ6qg}`?z6wM)@-I2RLLv9{DKhqdcnf^7RVNIjF3SH+Z}NH)ukzw~5mTFN=vo
z(TxnSH4-;{ln33$Y*8A0^3IaQHV`<Y)jzdXpLL2Yl7dHg9qjY4d)Db$o;DdAwPN~S
zCU(y{RqN`vIZ1W*tkZuxXPw$lePo8`LyL(2QEyur+w7KnBKvG&lTAxR9h$nK9*)i@
zxbtT6qH5;ui`{#AZnf!Rs<+tCo8Vv%$I`XCVgqtF*g{<Hhq!x0w!d@L?h)C>$?8Tn
z>h2NQ7js1RuGqk~Y2Q|2WA}VGp1`nsKHRtS`Ec}7B>Zzjcx@c4#@o#YZTU~Tj;By(
zfc4NX8Q$(e)-voJHHT&78~zc$J7}JTdGd+WIP@09@(eI+w7j`%IF*J4aER09^X0HN
z^X?g7yJvv;2k0O&B#*+>SiE}%n7^sCxvmH<y4^FtJh6KQ*hFC>H{Pm^7jlKk@w{B<
zjSX;d$Y+Qx`XrhN`<6T5cC&BE__tuuQUc(ROru^1fhX?_u#7$fEGn1eFd_q!W9S~3
z?EDsTNeZ$p2A$eH11#8-J3LItUk!~Nvw1dz*gXRb$4Ks;0oH-wmZ!Kzj#JDEedeKF
z?e-mg2G|~O-T~vRu1m*xu|~|O_aZoNNVbpn46uFLyBlG%hR66)olU);=8JJov_5wF
z@iTlRp&Qj{lVvMTzkBTT<2iQvG6Ym;*L6)2lcJM2D6LajL(JJ`U>OIUIcv?c0%qtS
zTocWe4W564)6NiM2ZuPj<gGcWN>#qV$=FEJ9tckpz}aWV<<9vyP^EUNeSEdKhBJY1
z811-x(DRt2%VXlY9ua4M|9p95iauaF7E50)#GdHa_yA#GD>Jl?Q+q2Xz43ap*0x@G
zpY_}UoJdsPsNozTF@(#S*KQ-wT|H+HqYNxzgud5sK1?DvkuOf<GJMEGqfg>Qpw>oP
zKA)V(S--k255uv(?=B8)!Cz6d5LB>GsaMu<Ru@y{c&5&TzQ4JEBaJ5US1ZoeDwS$|
zadO(5nVGE@XBNHU<kVz-x>)n_#k%;Z<|l+zUHJa*F34k77usu;_4ZP;6Ev33hZzFx
zeEvB>x<Gq!%{!Z)Ln;8jZLWK3?FALn&(ADP7HieoVy-$hIbHE)^D||!v`rhc96U1&
zrZ~=`n!<eUY-MF-LEhwZAwuAJqZ76?GdEc))@zH^Vr8y6mzyrzs~6qUbbu`vY;Jlc
zH&xBe)+VRCT&+6om7TjUx;bNDlR)^c0Tm{vt5bOlYHG5wSf8zwW8Ou#&^@3Y%}jf9
zxygLJmdm5T882UsukE;*d~PvFqM7cTTld=eT!<LOO8rcu?R5=nDqqc2i?vFzIF~En
zh~{$Qy#fv93)2fnU+@xnbn#~7o0#x1V?v&bF#*ML#cQ9#k>#rs6SC!riRUz+RRH<V
zm2uS6xfjdxW{z$Yaz`s|`9pNk)HN~jQXG}>A~2VYR?Rzl>r0MK)mzPV`46zRlFQ9`
zGqst@Vr3FjP%S4<Um}>ywa=~97I<=P7g*+|ax=w3ZL*l3TdaGP*>Y<A5;ZwX$|Q)o
zTAW#|&P*;Art@BPvObgd$^)0IMYxj}cyf7Hi-qZ_x%#wMU(6SaxqNN5Jh*cb-5%AZ
zWu{SAb5r%gbTKcfXliO^&MT)|PXMHae28)j(vu1HTkjrXZMt5o7IL{lF*h~k6$<5{
zH%jczO<fdrH<}arz@+xXM41QIJw8OP6)MxS)xy;5%v_-|HM>|IKKlefU=nwJidoqU
zK}Ka4>}%d!wK|=z)xcS1a&!6e$Xg{G^0~(khugW7>xqzcZgH_TIhUWySM&A!)MTMN
z`Zm?6{NwM`9r9?-C(^6JRCO_5FD!b~xk`0%cCMURxkPg`MP}1AF%`_oEacVX%v_~7
zS)D5Hx%U#amY-9H1cx}WQ0a8Fo~u?S3zf=DA(zjAJSWS0e@xB56KDQ`KJxe|WzL(N
zgCO+0O1_W-$&~k9I=HBfi?@SIwOFXvW@qz@wcJc$Ha}V3f5`++%j345o2SC7S7zpl
zvxT{-d@kn|YUKm%ON9uz_PN!S#@eaPjpn@B!ptK0!n8L#T`5kNFS~U7Xk$&bNiMy)
z;aYBPW^!_N+RHC478Z+(<;zd)c(lGA+O15@1y)BFmgg6%vz7W{VRm|PW^Sf9RX(_L
ziY_#oGi|B5wDSd%xop{5VXjszF6L&zLZ<RwE?2%{=R-4F%NzW4%f|9^Q;U`S%v7a5
zSFFy}yz-&PE#H__J27!5{;gD3yvIkivy=Ipw>VpYvX-mB%qbt<4$}EN+gyOj)dUvI
zE*#yMsUDU8z_@7R6jWT-`JjF@UzDG&G}?xVk)Ntf&Qyx^#p&E^Wv(z=KGN7Z5~=gW
zi|Qv|q*A7?7v$NmT_^-iyjZKv)Tb(y*~z(Du6*UK+cY)(Vq|Q4(he)sD%HjUWb+E_
zU#PO+_PGMolnNOC?BwEH`KlkhU`6?9_Rcssyin+R5Sm?+MX$0r=T&FW?&PFbEkEs!
z3)U|+QXFI6Rt@ngtS~oQoSMnafD_kefnn9Md(So%MlHtemBjqCR9Vh6DhrCjx?o;_
z&R+#K&E=|IeR^uTJa+C<wOo|?>B5#xSF2E%U{Fq0W{ZnZ*2>veT&kvL)FHK7w_UGH
z&CSg~Q=XoiDO6{t%U54A*+Z<6ix|5gU5D>svXY;LV_>>koh+7*Ua}@>ddMRbx|+<-
zPEY5jr@V?+oSvDg)ymgw$0;rbt)wE{)!NK#uI3eCSk-ECGx_>#`Pxg?8W(4DwN@*@
zqN+>*q=jN32fOOJ<|V=&h@whovou|V*Ql0XoUY}na|PIR<zpL{sKI<8n83}=dQ%wW
zVxbC^WwBU=5WoJCjdKfiWhPh5RjX6g=}I2BS}5Oe$r_}eZ1V`Ga)l~<b<;&JKV6yj
zYULX{mkO|XGQZx#^x)-yQa&>^J6W8ao2i#?I&-O7oy0NK@I`hi3rm&uQWxIB{Wv!b
z5}BTYn{aZrRvy1}3^&s5W<VDT`Dzi&u9|~ivp8KTPrROn$X3qJ3-N<Ou9x$v0B@yf
zBSWOZG1UbG==+m%kT>4cVs3^`k>fupO`<~KqKs1PdIm?B*TO0F6{tAUDxH{kiGH9I
z$;YW<Rp%yWC#R+>a1vE(bJOMATVw}wa~IV??LbE-YwPG(ZT-b^zwF1?rwYua>0Gs5
zoSR;po1U62=ij4%c5&{7DA43`r4VLP9e#Y>gKKjR=4}B+PO+BvymDdZ&f!UPs@U$-
z;bO|?C_w$|h_|~|sO6`qFic@q3UiC)$(QaJec8g4cTb}u|LH<UxUUxTv*`0=rBa+K
z&XlKKeo+-qqq~hY84ZwEUDYpEre^B7$?D{Eu~?YQFP5h-9x_1g05bAA0+~s8Y~k9h
z7Am=^++?9zF78~nAY}4W0TrnMDF3NXS-l1Yr&4uxYHG1sE8w4*T6t#YrnGEw+H8_T
zlJM((7>##;T`YPCslaVCJp-R(dG?7kN^INIs6@dCaC5cFRJ}MgRfic^Tg3FuE$$dQ
zwz4&Q=}$#(YPM3Hnx4(i<tnfU$~W)aH@#Im@Z&Qii0~54qk0!&R%*G~xk3SM(z)4c
z1tfdR&PBc1V#H?8=W9z|?bJdq@AM43F1eY-slpUS2r4c=edm#}EgS6V2hUAI!cBuD
zW@`2NTy>`WjGeo-wrmMrOCOrbw!ul`(DgSq3Hj-KeinYF>FL7UT$LvJGk5NV-?H_5
z*m|!vy-LL^EKY+#&eUL1O_ravPnyLlEa_XvC+4=nU2RgYcUmx_i-iIpSe>fmtFyDU
zYPDQ?);2}w<~LT?OZ2-<`&M|N27;MHxCON=&gBc``P;UsAfLZou8A&58=hppv`}Gv
zwCAh2xk+%FnVHGj<YKW<ezqE#cMn%l`$Kz9N*dJ=ALVCm(~ufuXpYY;%^~Jhpe<3&
zPuB}jv7b94YhpB~y@2{|O>4gZZ*F_;1uNg=OTZZFbhK7yC%xh#!d_E_^6h*4N`rQu
zH!K6b7?5oC`6KF<rX5>;!N6i2L2t$vzia-&oruJ)XO;>xGv3r(wNS0pW{Z$=<?l|j
zI)WR1lsi(mp-0HOb0_07!r}|7;N6&`samC0nXN5O<|^Q1UipQro?0*+@-G_3&0<|z
zRv5{P_l38#eWbnolKs(#t;WfvPWyXC`ILcAT4gBvz49~vfgg2y=>hYzz@EB`!&)cn
z`@Ru%<yZ6l>;m4%dqi{==rMj7A-pbW`v;P^WWkqj2aiHtc~x|9tkdMhS`+ZdFU}#%
z2xnF`2j4G(Vm~;jD`aDDmzrCCW?OAC{JuNRdppEr1yNs9Q^P(2-o!)$Z=i0rDvb`J
zXuRWh6B9uRhJDwt1sA$F1;=!5lD0amJw|-*=9GcvHdd=BM*y@v?^IP@U=nM*=y)qD
zbwX7_$$R!Tc$hEDYj*iv2pVcOJ+m}juP)XKlQ8&d({l(-l@||if4qh6NXp4Q^07Jh
zOV~gGUj~nYd2S5I7c}*j)g^7sQ^WEpXOVAKR6E^~iPg0JiWsnld=|8zo%zj-yfeJ)
z>uJNCdYY*&wFRn`twDJSxVOD_x(yLnUpUwBR_dKW?ePTaZlq}tEU3d_&J4&KgzwLs
zRhMmVt$xq2eA-^x=+v8M*Us&LT{9D9W~sUe58_mAcBW99otd1PD!*dqnG@T)5T%Nw
zJX#?0dZ7wG;q2se9Yj7^DZlcPH4{uGMpK+E=H{khtLCPw#p&7E^1VA(nYSN}(!6Gt
zX1vPWoL4{)vM^I9&Q6u@yJRhprEo@O^SPPaVtukOT`5#%D&_lY+YrlztZg$69eAi_
zmb@u&ndzx~aSqXmN`9_<e&_D_?E%&0m4X17gNGW?BrgwDI0uM5ATHT}d>;*<R)hPg
zI9th87m;c-Gg*GsrEA6aKLNk0(}l`xu3mx3RIS!0%dftO9IXq$E#h<nmz^q3SJBYa
z<lHnw@?7~fV)+u`LB7k=1n7D2!Y<Bw2<gt`XKOR%2gRjIH^~<_xtGApXYz9%Jj{h@
z1pX@CWcjt?l}})B7v)moELID|`g#>PX`Z)Oew}#wHmw&|E45a$J-v<%eMq4B>hw&p
zx>&E)Jy<|cD_<`jpT!lif3`6akYrUa=5s~jLankmg~YRm#CDpT?lIzhvd;?}lLhn}
z!I~PZ3ol<=oT=m%tK}csc9MHlG96aPDAWpT^`?qBcqMa1s>4v%CstO@tRhEqavIz|
zm&@f5F!}$QIg{VEjVKO#jJEM5NKxckAcr1Wq!Borg~M|&xfE&8AnBnkAaEH524u;Q
z?G(NB+;mCzec$)?FX^%WPQM`~TappgQ4lB>Qx-MDSvbS@e(!rs6ug{#P27t1OWv6;
zo#8RsjlgQJccnc>s_j}t%w{c=mg79eSRy`+3D@AFULU^9r=y}2mj+X&J=s5K&&FxP
zRIxIJ91E_IN$zj0wK+CZS-{637@eeOA^!EXHV4dy$R~<=nKu@&!oMMIchY4C{B*O0
z-Fq<D@AaSoId(&S@d<yQW{mw@=gKAssuqP!`Zw3#CRwCOp{hnF5=6K({;l=5DTPqR
zQLar%o025+w;zBuAu0q^DWX9V$j|t<*WaefG+OBhw<IA)WbyB;zfB=`8ETp%#G;EN
z%ly0IpSbSs6kU;~i*>}^x7{SWg-O!b%`j$VUK)>f?vV}lk)gbZ>vg!Sn~BR9cj8`e
zuwCL%52K41>K3^ij#@0Z;o5Ap8hA1o>y&e8S~b?cC;na9CEG<J?qipZK<jJ3y(jC}
zCA5Nw0?&4>fI2R1twDPXPc`S?7tbu2ta;;nA(p^Xy@6IQ4B-!O6I<5)1M$L%Yn#>k
zW^tscqf#rCw`^5f*b*h$e<<pEu6$7!#*!lnYfObrk>Wl=&3<$jcK2)_=8U0vF*sWH
zrF1T{mWOy^;QK!oFRj#>xvLyX3mL|W1V9TQg(_&}KM|{G^>fu96JF^@31HOdy0j{3
za%KFd;?=k`bX>&>0oA(5*7vuE{oO$UZNG%_pV89Ld5)0IX#U{f6_|>k`7v@-J87q8
znX*b+b{w473}sZNHvddqUow`&d=Km1%Q|>>0wYC%WQqsj;-l9FWUH!a${GUPe=eTC
z>v~((s}sp5+!2F@*N9<)Jnd`%hWB5H%O|b)c=8QH!<|&&iyGiYhpOto6wj_ypN@_p
zV{M@UDxHBoG#F2n_FsuBD^+M(C6yYT!^Vg}MS<9rz&3m>uC7$0o62%jS~xgvRpbQ*
zULdC9zY)uDvAKz#8^<pC71gwUtGA<Fj-vFhiJs(jR=YemR!h0$p8Hljw^DyH<gf?_
zb2aG-$+%Zqk{?1!j{k1y?zyBpEy6c{GlRXtZjybWlG-FT`0vGwD>b;I7Z>hmBNJ1&
zQ1Ca<F6(~~r(?&W0u=ge13!w>twKHh|0i)ao}Z}hI85D7e->xs&lbP_MM&BzWei77
zl6cbbeqN47gZ^N<i9T!~AfiLiNuAjuRH^?}m{=x@X>v^LxL+P@5B5nmL@U_Ah2N=m
zU!feUn;Shhc_Qm*p8MZ~y>q#Yayz4&fr1SLdrl}cXagewOaJ@-U67tpP6fh#3UrEe
zwVHsj|3f@Nt(^R`{Xnz+5~n8D`CDxDi7U`<b;|Lc-hLb=l+)c2o_iRJ$J#@LJ`P8E
z^U=l8+qis`iMY8n;APkc<SB}Wu99T9F_)Pr9v<^u^|<V1WFDS-vH~tHYHi)Q>1!hr
t_0-1GXZ8sTF-=V<_5o-2HqW0S_7Oqe3pWO%vKZ{0-`d;0F}#4h{vX?3_mBVp

literal 0
HcmV?d00001

diff --git a/wasm-wasi-http-example/wit/command-extended.wit b/wasm-wasi-http-example/wit/command-extended.wit
new file mode 100644
index 00000000..06617794
--- /dev/null
+++ b/wasm-wasi-http-example/wit/command-extended.wit
@@ -0,0 +1,37 @@
+// All of the same imports and exports available in the wasi:cli/command world
+// with addition of HTTP proxy related imports:
+world command-extended {
+  import wasi:clocks/wall-clock@0.2.0-rc-2023-10-18;
+  import wasi:clocks/monotonic-clock@0.2.0-rc-2023-10-18;
+  import wasi:clocks/timezone@0.2.0-rc-2023-10-18;
+  import wasi:filesystem/types@0.2.0-rc-2023-10-18;
+  import wasi:filesystem/preopens@0.2.0-rc-2023-10-18;
+  import wasi:sockets/instance-network@0.2.0-rc-2023-10-18;
+  import wasi:sockets/ip-name-lookup@0.2.0-rc-2023-10-18;
+  import wasi:sockets/network@0.2.0-rc-2023-10-18;
+  import wasi:sockets/tcp-create-socket@0.2.0-rc-2023-10-18;
+  import wasi:sockets/tcp@0.2.0-rc-2023-10-18;
+  import wasi:sockets/udp-create-socket@0.2.0-rc-2023-10-18;
+  import wasi:sockets/udp@0.2.0-rc-2023-10-18;
+  import wasi:random/random@0.2.0-rc-2023-10-18;
+  import wasi:random/insecure@0.2.0-rc-2023-10-18;
+  import wasi:random/insecure-seed@0.2.0-rc-2023-10-18;
+  import wasi:io/poll@0.2.0-rc-2023-10-18;
+  import wasi:io/streams@0.2.0-rc-2023-10-18;
+  import wasi:cli/environment@0.2.0-rc-2023-10-18;
+  import wasi:cli/exit@0.2.0-rc-2023-10-18;
+  import wasi:cli/stdin@0.2.0-rc-2023-10-18;
+  import wasi:cli/stdout@0.2.0-rc-2023-10-18;
+  import wasi:cli/stderr@0.2.0-rc-2023-10-18;
+  import wasi:cli/terminal-input@0.2.0-rc-2023-10-18;
+  import wasi:cli/terminal-output@0.2.0-rc-2023-10-18;
+  import wasi:cli/terminal-stdin@0.2.0-rc-2023-10-18;
+  import wasi:cli/terminal-stdout@0.2.0-rc-2023-10-18;
+  import wasi:cli/terminal-stderr@0.2.0-rc-2023-10-18;
+
+  // We should replace all others with `include self.command`
+  // as soon as the unioning of worlds is available:
+  // https://github.com/WebAssembly/component-model/issues/169
+  import wasi:logging/logging@0.2.0-rc-2023-10-18;
+  import wasi:http/outgoing-handler@0.2.0-rc-2023-10-18;
+}
diff --git a/wasm-wasi-http-example/wit/deps/cli/command.wit b/wasm-wasi-http-example/wit/deps/cli/command.wit
new file mode 100644
index 00000000..d7ea2d91
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/cli/command.wit
@@ -0,0 +1,7 @@
+package wasi:cli@0.2.0-rc-2023-10-18;
+
+world command {
+  include reactor;
+
+  export run;
+}
diff --git a/wasm-wasi-http-example/wit/deps/cli/environment.wit b/wasm-wasi-http-example/wit/deps/cli/environment.wit
new file mode 100644
index 00000000..70065233
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/cli/environment.wit
@@ -0,0 +1,18 @@
+interface environment {
+  /// Get the POSIX-style environment variables.
+  ///
+  /// Each environment variable is provided as a pair of string variable names
+  /// and string value.
+  ///
+  /// Morally, these are a value import, but until value imports are available
+  /// in the component model, this import function should return the same
+  /// values each time it is called.
+  get-environment: func() -> list<tuple<string, string>>;
+
+  /// Get the POSIX-style arguments to the program.
+  get-arguments: func() -> list<string>;
+
+  /// Return a path that programs should use as their initial current working
+  /// directory, interpreting `.` as shorthand for this.
+  initial-cwd: func() -> option<string>;
+}
diff --git a/wasm-wasi-http-example/wit/deps/cli/exit.wit b/wasm-wasi-http-example/wit/deps/cli/exit.wit
new file mode 100644
index 00000000..d0c2b82a
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/cli/exit.wit
@@ -0,0 +1,4 @@
+interface exit {
+  /// Exit the current instance and any linked instances.
+  exit: func(status: result);
+}
diff --git a/wasm-wasi-http-example/wit/deps/cli/reactor.wit b/wasm-wasi-http-example/wit/deps/cli/reactor.wit
new file mode 100644
index 00000000..904b9946
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/cli/reactor.wit
@@ -0,0 +1,32 @@
+package wasi:cli@0.2.0-rc-2023-10-18;
+
+world reactor {
+  import wasi:clocks/wall-clock@0.2.0-rc-2023-10-18;
+  import wasi:clocks/monotonic-clock@0.2.0-rc-2023-10-18;
+  import wasi:clocks/timezone@0.2.0-rc-2023-10-18;
+  import wasi:filesystem/types@0.2.0-rc-2023-10-18;
+  import wasi:filesystem/preopens@0.2.0-rc-2023-10-18;
+  import wasi:sockets/instance-network@0.2.0-rc-2023-10-18;
+  import wasi:sockets/ip-name-lookup@0.2.0-rc-2023-10-18;
+  import wasi:sockets/network@0.2.0-rc-2023-10-18;
+  import wasi:sockets/tcp-create-socket@0.2.0-rc-2023-10-18;
+  import wasi:sockets/tcp@0.2.0-rc-2023-10-18;
+  import wasi:sockets/udp-create-socket@0.2.0-rc-2023-10-18;
+  import wasi:sockets/udp@0.2.0-rc-2023-10-18;
+  import wasi:random/random@0.2.0-rc-2023-10-18;
+  import wasi:random/insecure@0.2.0-rc-2023-10-18;
+  import wasi:random/insecure-seed@0.2.0-rc-2023-10-18;
+  import wasi:io/poll@0.2.0-rc-2023-10-18;
+  import wasi:io/streams@0.2.0-rc-2023-10-18;
+
+  import environment;
+  import exit;
+  import stdin;
+  import stdout;
+  import stderr;
+  import terminal-input;
+  import terminal-output;
+  import terminal-stdin;
+  import terminal-stdout;
+  import terminal-stderr;
+}
diff --git a/wasm-wasi-http-example/wit/deps/cli/run.wit b/wasm-wasi-http-example/wit/deps/cli/run.wit
new file mode 100644
index 00000000..a70ee8c0
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/cli/run.wit
@@ -0,0 +1,4 @@
+interface run {
+  /// Run the program.
+  run: func() -> result;
+}
diff --git a/wasm-wasi-http-example/wit/deps/cli/stdio.wit b/wasm-wasi-http-example/wit/deps/cli/stdio.wit
new file mode 100644
index 00000000..513ca92d
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/cli/stdio.wit
@@ -0,0 +1,17 @@
+interface stdin {
+  use wasi:io/streams@0.2.0-rc-2023-10-18.{input-stream};
+
+  get-stdin: func() -> input-stream;
+}
+
+interface stdout {
+  use wasi:io/streams@0.2.0-rc-2023-10-18.{output-stream};
+
+  get-stdout: func() -> output-stream;
+}
+
+interface stderr {
+  use wasi:io/streams@0.2.0-rc-2023-10-18.{output-stream};
+
+  get-stderr: func() -> output-stream;
+}
diff --git a/wasm-wasi-http-example/wit/deps/cli/terminal.wit b/wasm-wasi-http-example/wit/deps/cli/terminal.wit
new file mode 100644
index 00000000..47495769
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/cli/terminal.wit
@@ -0,0 +1,47 @@
+interface terminal-input {
+    /// The input side of a terminal.
+    resource terminal-input;
+
+    // In the future, this may include functions for disabling echoing,
+    // disabling input buffering so that keyboard events are sent through
+    // immediately, querying supported features, and so on.
+}
+
+interface terminal-output {
+    /// The output side of a terminal.
+    resource terminal-output;
+
+    // In the future, this may include functions for querying the terminal
+    // size, being notified of terminal size changes, querying supported
+    // features, and so on.
+}
+
+/// An interface providing an optional `terminal-input` for stdin as a
+/// link-time authority.
+interface terminal-stdin {
+    use terminal-input.{terminal-input};
+
+    /// If stdin is connected to a terminal, return a `terminal-input` handle
+    /// allowing further interaction with it.
+    get-terminal-stdin: func() -> option<terminal-input>;
+}
+
+/// An interface providing an optional `terminal-output` for stdout as a
+/// link-time authority.
+interface terminal-stdout {
+    use terminal-output.{terminal-output};
+
+    /// If stdout is connected to a terminal, return a `terminal-output` handle
+    /// allowing further interaction with it.
+    get-terminal-stdout: func() -> option<terminal-output>;
+}
+
+/// An interface providing an optional `terminal-output` for stderr as a
+/// link-time authority.
+interface terminal-stderr {
+    use terminal-output.{terminal-output};
+
+    /// If stderr is connected to a terminal, return a `terminal-output` handle
+    /// allowing further interaction with it.
+    get-terminal-stderr: func() -> option<terminal-output>;
+}
diff --git a/wasm-wasi-http-example/wit/deps/clocks/monotonic-clock.wit b/wasm-wasi-http-example/wit/deps/clocks/monotonic-clock.wit
new file mode 100644
index 00000000..c0ecb529
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/clocks/monotonic-clock.wit
@@ -0,0 +1,32 @@
+/// WASI Monotonic Clock is a clock API intended to let users measure elapsed
+/// time.
+///
+/// It is intended to be portable at least between Unix-family platforms and
+/// Windows.
+///
+/// A monotonic clock is a clock which has an unspecified initial value, and
+/// successive reads of the clock will produce non-decreasing values.
+///
+/// It is intended for measuring elapsed time.
+interface monotonic-clock {
+    use wasi:io/poll@0.2.0-rc-2023-10-18.{pollable};
+
+    /// A timestamp in nanoseconds.
+    type instant = u64;
+
+    /// Read the current value of the clock.
+    ///
+    /// The clock is monotonic, therefore calling this function repeatedly will
+    /// produce a sequence of non-decreasing values.
+    now: func() -> instant;
+
+    /// Query the resolution of the clock.
+    resolution: func() -> instant;
+
+    /// Create a `pollable` which will resolve once the specified time has been
+    /// reached.
+    subscribe: func(
+        when: instant,
+        absolute: bool
+    ) -> pollable;
+}
diff --git a/wasm-wasi-http-example/wit/deps/clocks/timezone.wit b/wasm-wasi-http-example/wit/deps/clocks/timezone.wit
new file mode 100644
index 00000000..e717e7b8
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/clocks/timezone.wit
@@ -0,0 +1,48 @@
+interface timezone {
+    use wall-clock.{datetime};
+
+    /// Return information needed to display the given `datetime`. This includes
+    /// the UTC offset, the time zone name, and a flag indicating whether
+    /// daylight saving time is active.
+    ///
+    /// If the timezone cannot be determined for the given `datetime`, return a
+    /// `timezone-display` for `UTC` with a `utc-offset` of 0 and no daylight
+    /// saving time.
+    display: func(when: datetime) -> timezone-display;
+
+    /// The same as `display`, but only return the UTC offset.
+    utc-offset: func(when: datetime) -> s32;
+
+    /// Information useful for displaying the timezone of a specific `datetime`.
+    ///
+    /// This information may vary within a single `timezone` to reflect daylight
+    /// saving time adjustments.
+    record timezone-display {
+        /// The number of seconds difference between UTC time and the local
+        /// time of the timezone.
+        ///
+        /// The returned value will always be less than 86400 which is the
+        /// number of seconds in a day (24*60*60).
+        ///
+        /// In implementations that do not expose an actual time zone, this
+        /// should return 0.
+        utc-offset: s32,
+
+        /// The abbreviated name of the timezone to display to a user. The name
+        /// `UTC` indicates Coordinated Universal Time. Otherwise, this should
+        /// reference local standards for the name of the time zone.
+        ///
+        /// In implementations that do not expose an actual time zone, this
+        /// should be the string `UTC`.
+        ///
+        /// In time zones that do not have an applicable name, a formatted
+        /// representation of the UTC offset may be returned, such as `-04:00`.
+        name: string,
+
+        /// Whether daylight saving time is active.
+        ///
+        /// In implementations that do not expose an actual time zone, this
+        /// should return false.
+        in-daylight-saving-time: bool,
+    }
+}
diff --git a/wasm-wasi-http-example/wit/deps/clocks/wall-clock.wit b/wasm-wasi-http-example/wit/deps/clocks/wall-clock.wit
new file mode 100644
index 00000000..c3956496
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/clocks/wall-clock.wit
@@ -0,0 +1,41 @@
+/// WASI Wall Clock is a clock API intended to let users query the current
+/// time. The name "wall" makes an analogy to a "clock on the wall", which
+/// is not necessarily monotonic as it may be reset.
+///
+/// It is intended to be portable at least between Unix-family platforms and
+/// Windows.
+///
+/// A wall clock is a clock which measures the date and time according to
+/// some external reference.
+///
+/// External references may be reset, so this clock is not necessarily
+/// monotonic, making it unsuitable for measuring elapsed time.
+///
+/// It is intended for reporting the current date and time for humans.
+interface wall-clock {
+    /// A time and date in seconds plus nanoseconds.
+    record datetime {
+        seconds: u64,
+        nanoseconds: u32,
+    }
+
+    /// Read the current value of the clock.
+    ///
+    /// This clock is not monotonic, therefore calling this function repeatedly
+    /// will not necessarily produce a sequence of non-decreasing values.
+    ///
+    /// The returned timestamps represent the number of seconds since
+    /// 1970-01-01T00:00:00Z, also known as [POSIX's Seconds Since the Epoch],
+    /// also known as [Unix Time].
+    ///
+    /// The nanoseconds field of the output is always less than 1000000000.
+    ///
+    /// [POSIX's Seconds Since the Epoch]: https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16
+    /// [Unix Time]: https://en.wikipedia.org/wiki/Unix_time
+    now: func() -> datetime;
+
+    /// Query the resolution of the clock.
+    ///
+    /// The nanoseconds field of the output is always less than 1000000000.
+    resolution: func() -> datetime;
+}
diff --git a/wasm-wasi-http-example/wit/deps/clocks/world.wit b/wasm-wasi-http-example/wit/deps/clocks/world.wit
new file mode 100644
index 00000000..cdfb51d9
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/clocks/world.wit
@@ -0,0 +1,7 @@
+package wasi:clocks@0.2.0-rc-2023-10-18;
+
+world imports {
+    import monotonic-clock;
+    import wall-clock;
+    import timezone;
+}
diff --git a/wasm-wasi-http-example/wit/deps/filesystem/preopens.wit b/wasm-wasi-http-example/wit/deps/filesystem/preopens.wit
new file mode 100644
index 00000000..3f787ac3
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/filesystem/preopens.wit
@@ -0,0 +1,6 @@
+interface preopens {
+    use types.{descriptor};
+
+    /// Return the set of preopened directories, and their path.
+    get-directories: func() -> list<tuple<descriptor, string>>;
+}
diff --git a/wasm-wasi-http-example/wit/deps/filesystem/types.wit b/wasm-wasi-http-example/wit/deps/filesystem/types.wit
new file mode 100644
index 00000000..af361354
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/filesystem/types.wit
@@ -0,0 +1,810 @@
+/// WASI filesystem is a filesystem API primarily intended to let users run WASI
+/// programs that access their files on their existing filesystems, without
+/// significant overhead.
+///
+/// It is intended to be roughly portable between Unix-family platforms and
+/// Windows, though it does not hide many of the major differences.
+///
+/// Paths are passed as interface-type `string`s, meaning they must consist of
+/// a sequence of Unicode Scalar Values (USVs). Some filesystems may contain
+/// paths which are not accessible by this API.
+///
+/// The directory separator in WASI is always the forward-slash (`/`).
+///
+/// All paths in WASI are relative paths, and are interpreted relative to a
+/// `descriptor` referring to a base directory. If a `path` argument to any WASI
+/// function starts with `/`, or if any step of resolving a `path`, including
+/// `..` and symbolic link steps, reaches a directory outside of the base
+/// directory, or reaches a symlink to an absolute or rooted path in the
+/// underlying filesystem, the function fails with `error-code::not-permitted`.
+///
+/// For more information about WASI path resolution and sandboxing, see
+/// [WASI filesystem path resolution].
+///
+/// [WASI filesystem path resolution]: https://github.com/WebAssembly/wasi-filesystem/blob/main/path-resolution.md
+interface types {
+    use wasi:io/streams@0.2.0-rc-2023-10-18.{input-stream, output-stream, error};
+    use wasi:clocks/wall-clock@0.2.0-rc-2023-10-18.{datetime};
+
+    /// File size or length of a region within a file.
+    type filesize = u64;
+
+    /// The type of a filesystem object referenced by a descriptor.
+    ///
+    /// Note: This was called `filetype` in earlier versions of WASI.
+    enum descriptor-type {
+        /// The type of the descriptor or file is unknown or is different from
+        /// any of the other types specified.
+        unknown,
+        /// The descriptor refers to a block device inode.
+        block-device,
+        /// The descriptor refers to a character device inode.
+        character-device,
+        /// The descriptor refers to a directory inode.
+        directory,
+        /// The descriptor refers to a named pipe.
+        fifo,
+        /// The file refers to a symbolic link inode.
+        symbolic-link,
+        /// The descriptor refers to a regular file inode.
+        regular-file,
+        /// The descriptor refers to a socket.
+        socket,
+    }
+
+    /// Descriptor flags.
+    ///
+    /// Note: This was called `fdflags` in earlier versions of WASI.
+    flags descriptor-flags {
+        /// Read mode: Data can be read.
+        read,
+        /// Write mode: Data can be written to.
+        write,
+        /// Request that writes be performed according to synchronized I/O file
+        /// integrity completion. The data stored in the file and the file's
+        /// metadata are synchronized. This is similar to `O_SYNC` in POSIX.
+        ///
+        /// The precise semantics of this operation have not yet been defined for
+        /// WASI. At this time, it should be interpreted as a request, and not a
+        /// requirement.
+        file-integrity-sync,
+        /// Request that writes be performed according to synchronized I/O data
+        /// integrity completion. Only the data stored in the file is
+        /// synchronized. This is similar to `O_DSYNC` in POSIX.
+        ///
+        /// The precise semantics of this operation have not yet been defined for
+        /// WASI. At this time, it should be interpreted as a request, and not a
+        /// requirement.
+        data-integrity-sync,
+        /// Requests that reads be performed at the same level of integrety
+        /// requested for writes. This is similar to `O_RSYNC` in POSIX.
+        ///
+        /// The precise semantics of this operation have not yet been defined for
+        /// WASI. At this time, it should be interpreted as a request, and not a
+        /// requirement.
+        requested-write-sync,
+        /// Mutating directories mode: Directory contents may be mutated.
+        ///
+        /// When this flag is unset on a descriptor, operations using the
+        /// descriptor which would create, rename, delete, modify the data or
+        /// metadata of filesystem objects, or obtain another handle which
+        /// would permit any of those, shall fail with `error-code::read-only` if
+        /// they would otherwise succeed.
+        ///
+        /// This may only be set on directories.
+        mutate-directory,
+    }
+
+    /// File attributes.
+    ///
+    /// Note: This was called `filestat` in earlier versions of WASI.
+    record descriptor-stat {
+        /// File type.
+        %type: descriptor-type,
+        /// Number of hard links to the file.
+        link-count: link-count,
+        /// For regular files, the file size in bytes. For symbolic links, the
+        /// length in bytes of the pathname contained in the symbolic link.
+        size: filesize,
+        /// Last data access timestamp.
+        ///
+        /// If the `option` is none, the platform doesn't maintain an access
+        /// timestamp for this file.
+        data-access-timestamp: option<datetime>,
+        /// Last data modification timestamp.
+        ///
+        /// If the `option` is none, the platform doesn't maintain a
+        /// modification timestamp for this file.
+        data-modification-timestamp: option<datetime>,
+        /// Last file status-change timestamp.
+        ///
+        /// If the `option` is none, the platform doesn't maintain a
+        /// status-change timestamp for this file.
+        status-change-timestamp: option<datetime>,
+    }
+
+    /// Flags determining the method of how paths are resolved.
+    flags path-flags {
+        /// As long as the resolved path corresponds to a symbolic link, it is
+        /// expanded.
+        symlink-follow,
+    }
+
+    /// Open flags used by `open-at`.
+    flags open-flags {
+        /// Create file if it does not exist, similar to `O_CREAT` in POSIX.
+        create,
+        /// Fail if not a directory, similar to `O_DIRECTORY` in POSIX.
+        directory,
+        /// Fail if file already exists, similar to `O_EXCL` in POSIX.
+        exclusive,
+        /// Truncate file to size 0, similar to `O_TRUNC` in POSIX.
+        truncate,
+    }
+
+    /// Permissions mode used by `open-at`, `change-file-permissions-at`, and
+    /// similar.
+    flags modes {
+        /// True if the resource is considered readable by the containing
+        /// filesystem.
+        readable,
+        /// True if the resource is considered writable by the containing
+        /// filesystem.
+        writable,
+        /// True if the resource is considered executable by the containing
+        /// filesystem. This does not apply to directories.
+        executable,
+    }
+
+    /// Access type used by `access-at`.
+    variant access-type {
+        /// Test for readability, writeability, or executability.
+        access(modes),
+
+        /// Test whether the path exists.
+        exists,
+    }
+
+    /// Number of hard links to an inode.
+    type link-count = u64;
+
+    /// When setting a timestamp, this gives the value to set it to.
+    variant new-timestamp {
+        /// Leave the timestamp set to its previous value.
+        no-change,
+        /// Set the timestamp to the current time of the system clock associated
+        /// with the filesystem.
+        now,
+        /// Set the timestamp to the given value.
+        timestamp(datetime),
+    }
+
+    /// A directory entry.
+    record directory-entry {
+        /// The type of the file referred to by this directory entry.
+        %type: descriptor-type,
+
+        /// The name of the object.
+        name: string,
+    }
+
+    /// Error codes returned by functions, similar to `errno` in POSIX.
+    /// Not all of these error codes are returned by the functions provided by this
+    /// API; some are used in higher-level library layers, and others are provided
+    /// merely for alignment with POSIX.
+    enum error-code {
+        /// Permission denied, similar to `EACCES` in POSIX.
+        access,
+        /// Resource unavailable, or operation would block, similar to `EAGAIN` and `EWOULDBLOCK` in POSIX.
+        would-block,
+        /// Connection already in progress, similar to `EALREADY` in POSIX.
+        already,
+        /// Bad descriptor, similar to `EBADF` in POSIX.
+        bad-descriptor,
+        /// Device or resource busy, similar to `EBUSY` in POSIX.
+        busy,
+        /// Resource deadlock would occur, similar to `EDEADLK` in POSIX.
+        deadlock,
+        /// Storage quota exceeded, similar to `EDQUOT` in POSIX.
+        quota,
+        /// File exists, similar to `EEXIST` in POSIX.
+        exist,
+        /// File too large, similar to `EFBIG` in POSIX.
+        file-too-large,
+        /// Illegal byte sequence, similar to `EILSEQ` in POSIX.
+        illegal-byte-sequence,
+        /// Operation in progress, similar to `EINPROGRESS` in POSIX.
+        in-progress,
+        /// Interrupted function, similar to `EINTR` in POSIX.
+        interrupted,
+        /// Invalid argument, similar to `EINVAL` in POSIX.
+        invalid,
+        /// I/O error, similar to `EIO` in POSIX.
+        io,
+        /// Is a directory, similar to `EISDIR` in POSIX.
+        is-directory,
+        /// Too many levels of symbolic links, similar to `ELOOP` in POSIX.
+        loop,
+        /// Too many links, similar to `EMLINK` in POSIX.
+        too-many-links,
+        /// Message too large, similar to `EMSGSIZE` in POSIX.
+        message-size,
+        /// Filename too long, similar to `ENAMETOOLONG` in POSIX.
+        name-too-long,
+        /// No such device, similar to `ENODEV` in POSIX.
+        no-device,
+        /// No such file or directory, similar to `ENOENT` in POSIX.
+        no-entry,
+        /// No locks available, similar to `ENOLCK` in POSIX.
+        no-lock,
+        /// Not enough space, similar to `ENOMEM` in POSIX.
+        insufficient-memory,
+        /// No space left on device, similar to `ENOSPC` in POSIX.
+        insufficient-space,
+        /// Not a directory or a symbolic link to a directory, similar to `ENOTDIR` in POSIX.
+        not-directory,
+        /// Directory not empty, similar to `ENOTEMPTY` in POSIX.
+        not-empty,
+        /// State not recoverable, similar to `ENOTRECOVERABLE` in POSIX.
+        not-recoverable,
+        /// Not supported, similar to `ENOTSUP` and `ENOSYS` in POSIX.
+        unsupported,
+        /// Inappropriate I/O control operation, similar to `ENOTTY` in POSIX.
+        no-tty,
+        /// No such device or address, similar to `ENXIO` in POSIX.
+        no-such-device,
+        /// Value too large to be stored in data type, similar to `EOVERFLOW` in POSIX.
+        overflow,
+        /// Operation not permitted, similar to `EPERM` in POSIX.
+        not-permitted,
+        /// Broken pipe, similar to `EPIPE` in POSIX.
+        pipe,
+        /// Read-only file system, similar to `EROFS` in POSIX.
+        read-only,
+        /// Invalid seek, similar to `ESPIPE` in POSIX.
+        invalid-seek,
+        /// Text file busy, similar to `ETXTBSY` in POSIX.
+        text-file-busy,
+        /// Cross-device link, similar to `EXDEV` in POSIX.
+        cross-device,
+    }
+
+    /// File or memory access pattern advisory information.
+    enum advice {
+        /// The application has no advice to give on its behavior with respect
+        /// to the specified data.
+        normal,
+        /// The application expects to access the specified data sequentially
+        /// from lower offsets to higher offsets.
+        sequential,
+        /// The application expects to access the specified data in a random
+        /// order.
+        random,
+        /// The application expects to access the specified data in the near
+        /// future.
+        will-need,
+        /// The application expects that it will not access the specified data
+        /// in the near future.
+        dont-need,
+        /// The application expects to access the specified data once and then
+        /// not reuse it thereafter.
+        no-reuse,
+    }
+
+    /// A 128-bit hash value, split into parts because wasm doesn't have a
+    /// 128-bit integer type.
+    record metadata-hash-value {
+       /// 64 bits of a 128-bit hash value.
+       lower: u64,
+       /// Another 64 bits of a 128-bit hash value.
+       upper: u64,
+    }
+
+    /// A descriptor is a reference to a filesystem object, which may be a file,
+    /// directory, named pipe, special file, or other object on which filesystem
+    /// calls may be made.
+    resource descriptor {
+        /// Return a stream for reading from a file, if available.
+        ///
+        /// May fail with an error-code describing why the file cannot be read.
+        ///
+        /// Multiple read, write, and append streams may be active on the same open
+        /// file and they do not interfere with each other.
+        ///
+        /// Note: This allows using `read-stream`, which is similar to `read` in POSIX.
+        read-via-stream: func(
+            /// The offset within the file at which to start reading.
+            offset: filesize,
+        ) -> result<input-stream, error-code>;
+
+        /// Return a stream for writing to a file, if available.
+        ///
+        /// May fail with an error-code describing why the file cannot be written.
+        ///
+        /// Note: This allows using `write-stream`, which is similar to `write` in
+        /// POSIX.
+        write-via-stream: func(
+            /// The offset within the file at which to start writing.
+            offset: filesize,
+        ) -> result<output-stream, error-code>;
+
+        /// Return a stream for appending to a file, if available.
+        ///
+        /// May fail with an error-code describing why the file cannot be appended.
+        ///
+        /// Note: This allows using `write-stream`, which is similar to `write` with
+        /// `O_APPEND` in in POSIX.
+        append-via-stream: func() -> result<output-stream, error-code>;
+
+        /// Provide file advisory information on a descriptor.
+        ///
+        /// This is similar to `posix_fadvise` in POSIX.
+        advise: func(
+            /// The offset within the file to which the advisory applies.
+            offset: filesize,
+            /// The length of the region to which the advisory applies.
+            length: filesize,
+            /// The advice.
+            advice: advice
+        ) -> result<_, error-code>;
+
+        /// Synchronize the data of a file to disk.
+        ///
+        /// This function succeeds with no effect if the file descriptor is not
+        /// opened for writing.
+        ///
+        /// Note: This is similar to `fdatasync` in POSIX.
+        sync-data: func() -> result<_, error-code>;
+
+        /// Get flags associated with a descriptor.
+        ///
+        /// Note: This returns similar flags to `fcntl(fd, F_GETFL)` in POSIX.
+        ///
+        /// Note: This returns the value that was the `fs_flags` value returned
+        /// from `fdstat_get` in earlier versions of WASI.
+        get-flags: func() -> result<descriptor-flags, error-code>;
+
+        /// Get the dynamic type of a descriptor.
+        ///
+        /// Note: This returns the same value as the `type` field of the `fd-stat`
+        /// returned by `stat`, `stat-at` and similar.
+        ///
+        /// Note: This returns similar flags to the `st_mode & S_IFMT` value provided
+        /// by `fstat` in POSIX.
+        ///
+        /// Note: This returns the value that was the `fs_filetype` value returned
+        /// from `fdstat_get` in earlier versions of WASI.
+        get-type: func() -> result<descriptor-type, error-code>;
+
+        /// Adjust the size of an open file. If this increases the file's size, the
+        /// extra bytes are filled with zeros.
+        ///
+        /// Note: This was called `fd_filestat_set_size` in earlier versions of WASI.
+        set-size: func(size: filesize) -> result<_, error-code>;
+
+        /// Adjust the timestamps of an open file or directory.
+        ///
+        /// Note: This is similar to `futimens` in POSIX.
+        ///
+        /// Note: This was called `fd_filestat_set_times` in earlier versions of WASI.
+        set-times: func(
+            /// The desired values of the data access timestamp.
+            data-access-timestamp: new-timestamp,
+            /// The desired values of the data modification timestamp.
+            data-modification-timestamp: new-timestamp,
+        ) -> result<_, error-code>;
+
+        /// Read from a descriptor, without using and updating the descriptor's offset.
+        ///
+        /// This function returns a list of bytes containing the data that was
+        /// read, along with a bool which, when true, indicates that the end of the
+        /// file was reached. The returned list will contain up to `length` bytes; it
+        /// may return fewer than requested, if the end of the file is reached or
+        /// if the I/O operation is interrupted.
+        ///
+        /// In the future, this may change to return a `stream<u8, error-code>`.
+        ///
+        /// Note: This is similar to `pread` in POSIX.
+        read: func(
+            /// The maximum number of bytes to read.
+            length: filesize,
+            /// The offset within the file at which to read.
+            offset: filesize,
+        ) -> result<tuple<list<u8>, bool>, error-code>;
+
+        /// Write to a descriptor, without using and updating the descriptor's offset.
+        ///
+        /// It is valid to write past the end of a file; the file is extended to the
+        /// extent of the write, with bytes between the previous end and the start of
+        /// the write set to zero.
+        ///
+        /// In the future, this may change to take a `stream<u8, error-code>`.
+        ///
+        /// Note: This is similar to `pwrite` in POSIX.
+        write: func(
+            /// Data to write
+            buffer: list<u8>,
+            /// The offset within the file at which to write.
+            offset: filesize,
+        ) -> result<filesize, error-code>;
+
+        /// Read directory entries from a directory.
+        ///
+        /// On filesystems where directories contain entries referring to themselves
+        /// and their parents, often named `.` and `..` respectively, these entries
+        /// are omitted.
+        ///
+        /// This always returns a new stream which starts at the beginning of the
+        /// directory. Multiple streams may be active on the same directory, and they
+        /// do not interfere with each other.
+        read-directory: func() -> result<directory-entry-stream, error-code>;
+
+        /// Synchronize the data and metadata of a file to disk.
+        ///
+        /// This function succeeds with no effect if the file descriptor is not
+        /// opened for writing.
+        ///
+        /// Note: This is similar to `fsync` in POSIX.
+        sync: func() -> result<_, error-code>;
+
+        /// Create a directory.
+        ///
+        /// Note: This is similar to `mkdirat` in POSIX.
+        create-directory-at: func(
+            /// The relative path at which to create the directory.
+            path: string,
+        ) -> result<_, error-code>;
+
+        /// Return the attributes of an open file or directory.
+        ///
+        /// Note: This is similar to `fstat` in POSIX, except that it does not return
+        /// device and inode information. For testing whether two descriptors refer to
+        /// the same underlying filesystem object, use `is-same-object`. To obtain
+        /// additional data that can be used do determine whether a file has been
+        /// modified, use `metadata-hash`.
+        ///
+        /// Note: This was called `fd_filestat_get` in earlier versions of WASI.
+        stat: func() -> result<descriptor-stat, error-code>;
+
+        /// Return the attributes of a file or directory.
+        ///
+        /// Note: This is similar to `fstatat` in POSIX, except that it does not
+        /// return device and inode information. See the `stat` description for a
+        /// discussion of alternatives.
+        ///
+        /// Note: This was called `path_filestat_get` in earlier versions of WASI.
+        stat-at: func(
+            /// Flags determining the method of how the path is resolved.
+            path-flags: path-flags,
+            /// The relative path of the file or directory to inspect.
+            path: string,
+        ) -> result<descriptor-stat, error-code>;
+
+        /// Adjust the timestamps of a file or directory.
+        ///
+        /// Note: This is similar to `utimensat` in POSIX.
+        ///
+        /// Note: This was called `path_filestat_set_times` in earlier versions of
+        /// WASI.
+        set-times-at: func(
+            /// Flags determining the method of how the path is resolved.
+            path-flags: path-flags,
+            /// The relative path of the file or directory to operate on.
+            path: string,
+            /// The desired values of the data access timestamp.
+            data-access-timestamp: new-timestamp,
+            /// The desired values of the data modification timestamp.
+            data-modification-timestamp: new-timestamp,
+        ) -> result<_, error-code>;
+
+        /// Create a hard link.
+        ///
+        /// Note: This is similar to `linkat` in POSIX.
+        link-at: func(
+            /// Flags determining the method of how the path is resolved.
+            old-path-flags: path-flags,
+            /// The relative source path from which to link.
+            old-path: string,
+            /// The base directory for `new-path`.
+            new-descriptor: borrow<descriptor>,
+            /// The relative destination path at which to create the hard link.
+            new-path: string,
+        ) -> result<_, error-code>;
+
+        /// Open a file or directory.
+        ///
+        /// The returned descriptor is not guaranteed to be the lowest-numbered
+        /// descriptor not currently open/ it is randomized to prevent applications
+        /// from depending on making assumptions about indexes, since this is
+        /// error-prone in multi-threaded contexts. The returned descriptor is
+        /// guaranteed to be less than 2**31.
+        ///
+        /// If `flags` contains `descriptor-flags::mutate-directory`, and the base
+        /// descriptor doesn't have `descriptor-flags::mutate-directory` set,
+        /// `open-at` fails with `error-code::read-only`.
+        ///
+        /// If `flags` contains `write` or `mutate-directory`, or `open-flags`
+        /// contains `truncate` or `create`, and the base descriptor doesn't have
+        /// `descriptor-flags::mutate-directory` set, `open-at` fails with
+        /// `error-code::read-only`.
+        ///
+        /// Note: This is similar to `openat` in POSIX.
+        open-at: func(
+            /// Flags determining the method of how the path is resolved.
+            path-flags: path-flags,
+            /// The relative path of the object to open.
+            path: string,
+            /// The method by which to open the file.
+            open-flags: open-flags,
+            /// Flags to use for the resulting descriptor.
+            %flags: descriptor-flags,
+            /// Permissions to use when creating a new file.
+            modes: modes
+        ) -> result<descriptor, error-code>;
+
+        /// Read the contents of a symbolic link.
+        ///
+        /// If the contents contain an absolute or rooted path in the underlying
+        /// filesystem, this function fails with `error-code::not-permitted`.
+        ///
+        /// Note: This is similar to `readlinkat` in POSIX.
+        readlink-at: func(
+            /// The relative path of the symbolic link from which to read.
+            path: string,
+        ) -> result<string, error-code>;
+
+        /// Remove a directory.
+        ///
+        /// Return `error-code::not-empty` if the directory is not empty.
+        ///
+        /// Note: This is similar to `unlinkat(fd, path, AT_REMOVEDIR)` in POSIX.
+        remove-directory-at: func(
+            /// The relative path to a directory to remove.
+            path: string,
+        ) -> result<_, error-code>;
+
+        /// Rename a filesystem object.
+        ///
+        /// Note: This is similar to `renameat` in POSIX.
+        rename-at: func(
+            /// The relative source path of the file or directory to rename.
+            old-path: string,
+            /// The base directory for `new-path`.
+            new-descriptor: borrow<descriptor>,
+            /// The relative destination path to which to rename the file or directory.
+            new-path: string,
+        ) -> result<_, error-code>;
+
+        /// Create a symbolic link (also known as a "symlink").
+        ///
+        /// If `old-path` starts with `/`, the function fails with
+        /// `error-code::not-permitted`.
+        ///
+        /// Note: This is similar to `symlinkat` in POSIX.
+        symlink-at: func(
+            /// The contents of the symbolic link.
+            old-path: string,
+            /// The relative destination path at which to create the symbolic link.
+            new-path: string,
+        ) -> result<_, error-code>;
+
+        /// Check accessibility of a filesystem path.
+        ///
+        /// Check whether the given filesystem path names an object which is
+        /// readable, writable, or executable, or whether it exists.
+        ///
+        /// This does not a guarantee that subsequent accesses will succeed, as
+        /// filesystem permissions may be modified asynchronously by external
+        /// entities.
+        ///
+        /// Note: This is similar to `faccessat` with the `AT_EACCESS` flag in POSIX.
+        access-at: func(
+            /// Flags determining the method of how the path is resolved.
+            path-flags: path-flags,
+            /// The relative path to check.
+            path: string,
+            /// The type of check to perform.
+            %type: access-type
+        ) -> result<_, error-code>;
+
+        /// Unlink a filesystem object that is not a directory.
+        ///
+        /// Return `error-code::is-directory` if the path refers to a directory.
+        /// Note: This is similar to `unlinkat(fd, path, 0)` in POSIX.
+        unlink-file-at: func(
+            /// The relative path to a file to unlink.
+            path: string,
+        ) -> result<_, error-code>;
+
+        /// Change the permissions of a filesystem object that is not a directory.
+        ///
+        /// Note that the ultimate meanings of these permissions is
+        /// filesystem-specific.
+        ///
+        /// Note: This is similar to `fchmodat` in POSIX.
+        change-file-permissions-at: func(
+            /// Flags determining the method of how the path is resolved.
+            path-flags: path-flags,
+            /// The relative path to operate on.
+            path: string,
+            /// The new permissions for the filesystem object.
+            modes: modes,
+        ) -> result<_, error-code>;
+
+        /// Change the permissions of a directory.
+        ///
+        /// Note that the ultimate meanings of these permissions is
+        /// filesystem-specific.
+        ///
+        /// Unlike in POSIX, the `executable` flag is not reinterpreted as a "search"
+        /// flag. `read` on a directory implies readability and searchability, and
+        /// `execute` is not valid for directories.
+        ///
+        /// Note: This is similar to `fchmodat` in POSIX.
+        change-directory-permissions-at: func(
+            /// Flags determining the method of how the path is resolved.
+            path-flags: path-flags,
+            /// The relative path to operate on.
+            path: string,
+            /// The new permissions for the directory.
+            modes: modes,
+        ) -> result<_, error-code>;
+
+        /// Request a shared advisory lock for an open file.
+        ///
+        /// This requests a *shared* lock; more than one shared lock can be held for
+        /// a file at the same time.
+        ///
+        /// If the open file has an exclusive lock, this function downgrades the lock
+        /// to a shared lock. If it has a shared lock, this function has no effect.
+        ///
+        /// This requests an *advisory* lock, meaning that the file could be accessed
+        /// by other programs that don't hold the lock.
+        ///
+        /// It is unspecified how shared locks interact with locks acquired by
+        /// non-WASI programs.
+        ///
+        /// This function blocks until the lock can be acquired.
+        ///
+        /// Not all filesystems support locking; on filesystems which don't support
+        /// locking, this function returns `error-code::unsupported`.
+        ///
+        /// Note: This is similar to `flock(fd, LOCK_SH)` in Unix.
+        lock-shared: func() -> result<_, error-code>;
+
+        /// Request an exclusive advisory lock for an open file.
+        ///
+        /// This requests an *exclusive* lock; no other locks may be held for the
+        /// file while an exclusive lock is held.
+        ///
+        /// If the open file has a shared lock and there are no exclusive locks held
+        /// for the file, this function upgrades the lock to an exclusive lock. If the
+        /// open file already has an exclusive lock, this function has no effect.
+        ///
+        /// This requests an *advisory* lock, meaning that the file could be accessed
+        /// by other programs that don't hold the lock.
+        ///
+        /// It is unspecified whether this function succeeds if the file descriptor
+        /// is not opened for writing. It is unspecified how exclusive locks interact
+        /// with locks acquired by non-WASI programs.
+        ///
+        /// This function blocks until the lock can be acquired.
+        ///
+        /// Not all filesystems support locking; on filesystems which don't support
+        /// locking, this function returns `error-code::unsupported`.
+        ///
+        /// Note: This is similar to `flock(fd, LOCK_EX)` in Unix.
+        lock-exclusive: func() -> result<_, error-code>;
+
+        /// Request a shared advisory lock for an open file.
+        ///
+        /// This requests a *shared* lock; more than one shared lock can be held for
+        /// a file at the same time.
+        ///
+        /// If the open file has an exclusive lock, this function downgrades the lock
+        /// to a shared lock. If it has a shared lock, this function has no effect.
+        ///
+        /// This requests an *advisory* lock, meaning that the file could be accessed
+        /// by other programs that don't hold the lock.
+        ///
+        /// It is unspecified how shared locks interact with locks acquired by
+        /// non-WASI programs.
+        ///
+        /// This function returns `error-code::would-block` if the lock cannot be
+        /// acquired.
+        ///
+        /// Not all filesystems support locking; on filesystems which don't support
+        /// locking, this function returns `error-code::unsupported`.
+        ///
+        /// Note: This is similar to `flock(fd, LOCK_SH | LOCK_NB)` in Unix.
+        try-lock-shared: func() -> result<_, error-code>;
+
+        /// Request an exclusive advisory lock for an open file.
+        ///
+        /// This requests an *exclusive* lock; no other locks may be held for the
+        /// file while an exclusive lock is held.
+        ///
+        /// If the open file has a shared lock and there are no exclusive locks held
+        /// for the file, this function upgrades the lock to an exclusive lock. If the
+        /// open file already has an exclusive lock, this function has no effect.
+        ///
+        /// This requests an *advisory* lock, meaning that the file could be accessed
+        /// by other programs that don't hold the lock.
+        ///
+        /// It is unspecified whether this function succeeds if the file descriptor
+        /// is not opened for writing. It is unspecified how exclusive locks interact
+        /// with locks acquired by non-WASI programs.
+        ///
+        /// This function returns `error-code::would-block` if the lock cannot be
+        /// acquired.
+        ///
+        /// Not all filesystems support locking; on filesystems which don't support
+        /// locking, this function returns `error-code::unsupported`.
+        ///
+        /// Note: This is similar to `flock(fd, LOCK_EX | LOCK_NB)` in Unix.
+        try-lock-exclusive: func() -> result<_, error-code>;
+
+        /// Release a shared or exclusive lock on an open file.
+        ///
+        /// Note: This is similar to `flock(fd, LOCK_UN)` in Unix.
+        unlock: func() -> result<_, error-code>;
+
+        /// Test whether two descriptors refer to the same filesystem object.
+        ///
+        /// In POSIX, this corresponds to testing whether the two descriptors have the
+        /// same device (`st_dev`) and inode (`st_ino` or `d_ino`) numbers.
+        /// wasi-filesystem does not expose device and inode numbers, so this function
+        /// may be used instead.
+        is-same-object: func(other: borrow<descriptor>) -> bool;
+
+        /// Return a hash of the metadata associated with a filesystem object referred
+        /// to by a descriptor.
+        ///
+        /// This returns a hash of the last-modification timestamp and file size, and
+        /// may also include the inode number, device number, birth timestamp, and
+        /// other metadata fields that may change when the file is modified or
+        /// replaced. It may also include a secret value chosen by the
+        /// implementation and not otherwise exposed.
+        ///
+        /// Implementations are encourated to provide the following properties:
+        ///
+        ///  - If the file is not modified or replaced, the computed hash value should
+        ///    usually not change.
+        ///  - If the object is modified or replaced, the computed hash value should
+        ///    usually change.
+        ///  - The inputs to the hash should not be easily computable from the
+        ///    computed hash.
+        ///
+        /// However, none of these is required.
+        metadata-hash: func() -> result<metadata-hash-value, error-code>;
+
+        /// Return a hash of the metadata associated with a filesystem object referred
+        /// to by a directory descriptor and a relative path.
+        ///
+        /// This performs the same hash computation as `metadata-hash`.
+        metadata-hash-at: func(
+            /// Flags determining the method of how the path is resolved.
+            path-flags: path-flags,
+            /// The relative path of the file or directory to inspect.
+            path: string,
+        ) -> result<metadata-hash-value, error-code>;
+    }
+
+    /// A stream of directory entries.
+    resource directory-entry-stream {
+        /// Read a single directory entry from a `directory-entry-stream`.
+        read-directory-entry: func() -> result<option<directory-entry>, error-code>;
+    }
+
+    /// Attempts to extract a filesystem-related `error-code` from the stream
+    /// `error` provided.
+    ///
+    /// Stream operations which return `stream-error::last-operation-failed`
+    /// have a payload with more information about the operation that failed.
+    /// This payload can be passed through to this function to see if there's
+    /// filesystem-related information about the error to return.
+    ///
+    /// Note that this function is fallible because not all stream-related
+    /// errors are filesystem-related errors.
+    filesystem-error-code: func(err: borrow<error>) -> option<error-code>;
+}
diff --git a/wasm-wasi-http-example/wit/deps/filesystem/world.wit b/wasm-wasi-http-example/wit/deps/filesystem/world.wit
new file mode 100644
index 00000000..3f953f89
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/filesystem/world.wit
@@ -0,0 +1,6 @@
+package wasi:filesystem@0.2.0-rc-2023-10-18;
+
+world imports {
+    import types;
+    import preopens;
+}
diff --git a/wasm-wasi-http-example/wit/deps/http/incoming-handler.wit b/wasm-wasi-http-example/wit/deps/http/incoming-handler.wit
new file mode 100644
index 00000000..6968d633
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/http/incoming-handler.wit
@@ -0,0 +1,24 @@
+// The `wasi:http/incoming-handler` interface is meant to be exported by
+// components and called by the host in response to a new incoming HTTP
+// response.
+//
+//   NOTE: in Preview3, this interface will be merged with
+//   `wasi:http/outgoing-handler` into a single `wasi:http/handler` interface
+//   that takes a `request` parameter and returns a `response` result.
+//
+interface incoming-handler {
+  use types.{incoming-request, response-outparam};
+
+  // The `handle` function takes an outparam instead of returning its response
+  // so that the component may stream its response while streaming any other
+  // request or response bodies. The callee MUST write a response to the
+  // `response-outparam` and then finish the response before returning. The `handle`
+  // function is allowed to continue execution after finishing the response's
+  // output stream. While this post-response execution is taken off the
+  // critical path, since there is no return value, there is no way to report
+  // its success or failure.
+  handle: func(
+    request: incoming-request,
+    response-out: response-outparam
+  );
+}
diff --git a/wasm-wasi-http-example/wit/deps/http/outgoing-handler.wit b/wasm-wasi-http-example/wit/deps/http/outgoing-handler.wit
new file mode 100644
index 00000000..286e2833
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/http/outgoing-handler.wit
@@ -0,0 +1,20 @@
+// The `wasi:http/outgoing-handler` interface is meant to be imported by
+// components and implemented by the host.
+//
+//   NOTE: in Preview3, this interface will be merged with
+//   `wasi:http/outgoing-handler` into a single `wasi:http/handler` interface
+//   that takes a `request` parameter and returns a `response` result.
+//
+interface outgoing-handler {
+  use types.{outgoing-request, request-options, future-incoming-response, error};
+
+  // The parameter and result types of the `handle` function allow the caller
+  // to concurrently stream the bodies of the outgoing request and the incoming
+  // response.
+  // Consumes the outgoing-request. Gives an error if the outgoing-request
+  // is invalid or cannot be satisfied by this handler.
+  handle: func(
+    request: outgoing-request,
+    options: option<request-options>
+  ) -> result<future-incoming-response, error>;
+}
diff --git a/wasm-wasi-http-example/wit/deps/http/proxy.wit b/wasm-wasi-http-example/wit/deps/http/proxy.wit
new file mode 100644
index 00000000..dde0659d
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/http/proxy.wit
@@ -0,0 +1,34 @@
+package wasi:http@0.2.0-rc-2023-10-18;
+
+// The `wasi:http/proxy` world captures a widely-implementable intersection of
+// hosts that includes HTTP forward and reverse proxies. Components targeting
+// this world may concurrently stream in and out any number of incoming and
+// outgoing HTTP requests.
+world proxy {
+  // HTTP proxies have access to time and randomness.
+  import wasi:clocks/wall-clock@0.2.0-rc-2023-10-18;
+  import wasi:clocks/monotonic-clock@0.2.0-rc-2023-10-18;
+  import wasi:clocks/timezone@0.2.0-rc-2023-10-18;
+  import wasi:random/random@0.2.0-rc-2023-10-18;
+
+  // Proxies have standard output and error streams which are expected to
+  // terminate in a developer-facing console provided by the host.
+  import wasi:cli/stdout@0.2.0-rc-2023-10-18;
+  import wasi:cli/stderr@0.2.0-rc-2023-10-18;
+
+  // TODO: this is a temporary workaround until component tooling is able to
+  // gracefully handle the absence of stdin. Hosts must return an eof stream
+  // for this import, which is what wasi-libc + tooling will do automatically
+  // when this import is properly removed.
+  import wasi:cli/stdin@0.2.0-rc-2023-10-18;
+
+  // This is the default handler to use when user code simply wants to make an
+  // HTTP request (e.g., via `fetch()`).
+  import outgoing-handler;
+
+  // The host delivers incoming HTTP requests to a component by calling the
+  // `handle` function of this exported interface. A host may arbitrarily reuse
+  // or not reuse component instance when delivering incoming HTTP requests and
+  // thus a component must be able to handle 0..N calls to `handle`.
+  export incoming-handler;
+}
diff --git a/wasm-wasi-http-example/wit/deps/http/types.wit b/wasm-wasi-http-example/wit/deps/http/types.wit
new file mode 100644
index 00000000..2cd2fe21
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/http/types.wit
@@ -0,0 +1,214 @@
+// The `wasi:http/types` interface is meant to be imported by components to
+// define the HTTP resource types and operations used by the component's
+// imported and exported interfaces.
+interface types {
+  use wasi:io/streams@0.2.0-rc-2023-10-18.{input-stream, output-stream};
+  use wasi:io/poll@0.2.0-rc-2023-10-18.{pollable};
+
+  // This type corresponds to HTTP standard Methods.
+  variant method {
+    get,
+    head,
+    post,
+    put,
+    delete,
+    connect,
+    options,
+    trace,
+    patch,
+    other(string)
+  }
+
+  // This type corresponds to HTTP standard Related Schemes.
+  variant scheme {
+    HTTP,
+    HTTPS,
+    other(string)
+  }
+
+  // TODO: perhaps better align with HTTP semantics?
+  // This type enumerates the different kinds of errors that may occur when
+  // initially returning a response.
+  variant error {
+    invalid-url(string),
+    timeout-error(string),
+    protocol-error(string),
+    unexpected-error(string)
+  }
+
+  // This following block defines the `fields` resource which corresponds to
+  // HTTP standard Fields. Soon, when resource types are added, the `type
+  // fields = u32` type alias can be replaced by a proper `resource fields`
+  // definition containing all the functions using the method syntactic sugar.
+  resource fields {
+    // Multiple values for a header are multiple entries in the list with the
+    // same key.
+    constructor(entries: list<tuple<string,list<u8>>>);
+
+    // Values off wire are not necessarily well formed, so they are given by
+    // list<u8> instead of string.
+    get: func(name: string) -> list<list<u8>>;
+
+    // Values off wire are not necessarily well formed, so they are given by
+    // list<u8> instead of string.
+    set: func(name: string, value: list<list<u8>>);
+    delete: func(name: string);
+    append: func(name: string, value: list<u8>);
+
+    // Values off wire are not necessarily well formed, so they are given by
+    // list<u8> instead of string.
+    entries: func() -> list<tuple<string,list<u8>>>;
+
+    // Deep copy of all contents in a fields.
+    clone: func() -> fields;
+  }
+
+  type headers = fields;
+  type trailers = fields;
+
+  // The following block defines the `incoming-request` and `outgoing-request`
+  // resource types that correspond to HTTP standard Requests. Soon, when
+  // resource types are added, the `u32` type aliases can be replaced by
+  // proper `resource` type definitions containing all the functions as
+  // methods. Later, Preview2 will allow both types to be merged together into
+  // a single `request` type (that uses the single `stream` type mentioned
+  // above). The `consume` and `write` methods may only be called once (and
+  // return failure thereafter).
+  resource incoming-request {
+    method: func() -> method;
+
+    path-with-query: func() -> option<string>;
+
+    scheme: func() -> option<scheme>;
+
+    authority: func() -> option<string>;
+
+    headers: func() -> /* child */ headers;
+    // Will return the input-stream child at most once. If called more than
+    // once, subsequent calls will return error.
+
+    consume: func() -> result<incoming-body>;
+  }
+
+  resource outgoing-request {
+    constructor(
+      method: method,
+      path-with-query: option<string>,
+      scheme: option<scheme>,
+      authority: option<string>,
+      headers: borrow<headers>
+    );
+
+    // Will return the outgoing-body child at most once. If called more than
+    // once, subsequent calls will return error.
+    write: func() -> result< /* child */ outgoing-body>;
+  }
+
+  // Additional optional parameters that can be set when making a request.
+  record request-options {
+    // The following timeouts are specific to the HTTP protocol and work
+    // independently of the overall timeouts passed to `io.poll.poll-list`.
+
+    // The timeout for the initial connect.
+    connect-timeout-ms: option<u32>,
+
+    // The timeout for receiving the first byte of the response body.
+    first-byte-timeout-ms: option<u32>,
+
+    // The timeout for receiving the next chunk of bytes in the response body
+    // stream.
+    between-bytes-timeout-ms: option<u32>
+  }
+
+  // The following block defines a special resource type used by the
+  // `wasi:http/incoming-handler` interface. When resource types are added, this
+  // block can be replaced by a proper `resource response-outparam { ... }`
+  // definition. Later, with Preview3, the need for an outparam goes away entirely
+  // (the `wasi:http/handler` interface used for both incoming and outgoing can
+  // simply return a `stream`).
+  resource response-outparam {
+    set: static func(param: response-outparam, response: result<outgoing-response, error>);
+  }
+
+  // This type corresponds to the HTTP standard Status Code.
+  type status-code = u16;
+
+  // The following block defines the `incoming-response` and `outgoing-response`
+  // resource types that correspond to HTTP standard Responses. Soon, when
+  // resource types are added, the `u32` type aliases can be replaced by proper
+  // `resource` type definitions containing all the functions as methods. Later,
+  // Preview2 will allow both types to be merged together into a single `response`
+  // type (that uses the single `stream` type mentioned above). The `consume` and
+  // `write` methods may only be called once (and return failure thereafter).
+  resource incoming-response {
+    status: func() -> status-code;
+
+    headers: func() -> /* child */ headers;
+
+    // May be called at most once. returns error if called additional times.
+    // TODO: make incoming-request-consume work the same way, giving a child
+    // incoming-body.
+    consume: func() -> result<incoming-body>;
+  }
+
+  resource incoming-body {
+    // returned input-stream is a child - the implementation may trap if
+    // incoming-body is dropped (or consumed by call to
+    // incoming-body-finish) before the input-stream is dropped.
+    // May be called at most once. returns error if called additional times.
+    %stream: func() -> result</* child */ input-stream>;
+
+    // takes ownership of incoming-body. this will trap if the
+    // incoming-body-stream child is still alive!
+    finish: static func(this: incoming-body) ->
+    /* transitive child of the incoming-response of incoming-body */ future-trailers;
+  }
+
+  resource future-trailers {
+    /// Pollable that resolves when the body has been fully read, and the trailers
+    /// are ready to be consumed.
+    subscribe: func() -> /* child */ pollable;
+
+    /// Retrieve reference to trailers, if they are ready.
+    get: func() -> option<result</* child */ trailers, error>>;
+  }
+
+  resource outgoing-response {
+    constructor(status-code: status-code, headers: borrow<headers>);
+
+    /// Will give the child outgoing-response at most once. subsequent calls will
+    /// return an error.
+    write: func() -> result<outgoing-body>;
+  }
+
+  resource outgoing-body {
+    /// Will give the child output-stream at most once. subsequent calls will
+    /// return an error.
+    write: func() -> result</* child */ output-stream>;
+
+    /// Finalize an outgoing body, optionally providing trailers. This must be
+    /// called to signal that the response is complete. If the `outgoing-body` is
+    /// dropped without calling `outgoing-body-finalize`, the implementation
+    /// should treat the body as corrupted.
+    finish: static func(this: outgoing-body, trailers: option<trailers>);
+  }
+
+  /// The following block defines a special resource type used by the
+  /// `wasi:http/outgoing-handler` interface to emulate
+  /// `future<result<response, error>>` in advance of Preview3. Given a
+  /// `future-incoming-response`, the client can call the non-blocking `get`
+  /// method to get the result if it is available. If the result is not available,
+  /// the client can call `listen` to get a `pollable` that can be passed to
+  /// `wasi:io/poll.poll-list`.
+  resource future-incoming-response {
+    /// option indicates readiness.
+    /// outer result indicates you are allowed to get the
+    /// incoming-response-or-error at most once. subsequent calls after ready
+    /// will return an error here.
+    /// inner result indicates whether the incoming-response was available, or an
+    /// error occured.
+    get: func() -> option<result<result</* NOT a child*/ incoming-response, error>>>;
+
+    subscribe: func() -> /* child */ pollable;
+  }
+}
diff --git a/wasm-wasi-http-example/wit/deps/io/poll.wit b/wasm-wasi-http-example/wit/deps/io/poll.wit
new file mode 100644
index 00000000..047389d2
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/io/poll.wit
@@ -0,0 +1,34 @@
+package wasi:io@0.2.0-rc-2023-10-18;
+
+/// A poll API intended to let users wait for I/O events on multiple handles
+/// at once.
+interface poll {
+    /// A "pollable" handle.
+    resource pollable;
+
+    /// Poll for completion on a set of pollables.
+    ///
+    /// This function takes a list of pollables, which identify I/O sources of
+    /// interest, and waits until one or more of the events is ready for I/O.
+    ///
+    /// The result `list<u32>` contains one or more indices of handles in the
+    /// argument list that is ready for I/O.
+    ///
+    /// If the list contains more elements than can be indexed with a `u32`
+    /// value, this function traps.
+    ///
+    /// A timeout can be implemented by adding a pollable from the
+    /// wasi-clocks API to the list.
+    ///
+    /// This function does not return a `result`; polling in itself does not
+    /// do any I/O so it doesn't fail. If any of the I/O sources identified by
+    /// the pollables has an error, it is indicated by marking the source as
+    /// being reaedy for I/O.
+    poll-list: func(in: list<borrow<pollable>>) -> list<u32>;
+
+    /// Poll for completion on a single pollable.
+    ///
+    /// This function is similar to `poll-list`, but operates on only a single
+    /// pollable. When it returns, the handle is ready for I/O.
+    poll-one: func(in: borrow<pollable>);
+}
diff --git a/wasm-wasi-http-example/wit/deps/io/streams.wit b/wasm-wasi-http-example/wit/deps/io/streams.wit
new file mode 100644
index 00000000..d0e8f5c3
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/io/streams.wit
@@ -0,0 +1,289 @@
+package wasi:io@0.2.0-rc-2023-10-18;
+
+/// WASI I/O is an I/O abstraction API which is currently focused on providing
+/// stream types.
+///
+/// In the future, the component model is expected to add built-in stream types;
+/// when it does, they are expected to subsume this API.
+interface streams {
+    use poll.{pollable};
+
+    /// An error for input-stream and output-stream operations.
+    variant stream-error {
+        /// The last operation (a write or flush) failed before completion.
+        ///
+        /// More information is available in the `error` payload.
+        last-operation-failed(error),
+        /// The stream is closed: no more input will be accepted by the
+        /// stream. A closed output-stream will return this error on all
+        /// future operations.
+        closed
+    }
+
+    /// Contextual error information about the last failure that happened on
+    /// a read, write, or flush from an `input-stream` or `output-stream`.
+    ///
+    /// This type is returned through the `stream-error` type whenever an
+    /// operation on a stream directly fails or an error is discovered
+    /// after-the-fact, for example when a write's failure shows up through a
+    /// later `flush` or `check-write`.
+    ///
+    /// Interfaces such as `wasi:filesystem/types` provide functionality to
+    /// further "downcast" this error into interface-specific error information.
+    resource error {
+        /// Returns a string that's suitable to assist humans in debugging this
+        /// error.
+        ///
+        /// The returned string will change across platforms and hosts which
+        /// means that parsing it, for example, would be a
+        /// platform-compatibility hazard.
+        to-debug-string: func() -> string;
+    }
+
+    /// An input bytestream.
+    ///
+    /// `input-stream`s are *non-blocking* to the extent practical on underlying
+    /// platforms. I/O operations always return promptly; if fewer bytes are
+    /// promptly available than requested, they return the number of bytes promptly
+    /// available, which could even be zero. To wait for data to be available,
+    /// use the `subscribe` function to obtain a `pollable` which can be polled
+    /// for using `wasi:io/poll`.
+    resource input-stream {
+        /// Perform a non-blocking read from the stream.
+        ///
+        /// This function returns a list of bytes containing the data that was
+        /// read, along with a `stream-status` which, indicates whether further
+        /// reads are expected to produce data. The returned list will contain up to
+        /// `len` bytes; it may return fewer than requested, but not more. An
+        /// empty list and `stream-status:open` indicates no more data is
+        /// available at this time, and that the pollable given by `subscribe`
+        /// will be ready when more data is available.
+        ///
+        /// Once a stream has reached the end, subsequent calls to `read` or
+        /// `skip` will always report `stream-status:ended` rather than producing more
+        /// data.
+        ///
+        /// When the caller gives a `len` of 0, it represents a request to read 0
+        /// bytes. This read should  always succeed and return an empty list and
+        /// the current `stream-status`.
+        ///
+        /// The `len` parameter is a `u64`, which could represent a list of u8 which
+        /// is not possible to allocate in wasm32, or not desirable to allocate as
+        /// as a return value by the callee. The callee may return a list of bytes
+        /// less than `len` in size while more bytes are available for reading.
+        read: func(
+            /// The maximum number of bytes to read
+            len: u64
+        ) -> result<list<u8>, stream-error>;
+
+        /// Read bytes from a stream, after blocking until at least one byte can
+        /// be read. Except for blocking, identical to `read`.
+        blocking-read: func(
+            /// The maximum number of bytes to read
+            len: u64
+        ) -> result<list<u8>, stream-error>;
+
+        /// Skip bytes from a stream.
+        ///
+        /// This is similar to the `read` function, but avoids copying the
+        /// bytes into the instance.
+        ///
+        /// Once a stream has reached the end, subsequent calls to read or
+        /// `skip` will always report end-of-stream rather than producing more
+        /// data.
+        ///
+        /// This function returns the number of bytes skipped, along with a
+        /// `stream-status` indicating whether the end of the stream was
+        /// reached. The returned value will be at most `len`; it may be less.
+        skip: func(
+            /// The maximum number of bytes to skip.
+            len: u64,
+        ) -> result<u64, stream-error>;
+
+        /// Skip bytes from a stream, after blocking until at least one byte
+        /// can be skipped. Except for blocking behavior, identical to `skip`.
+        blocking-skip: func(
+            /// The maximum number of bytes to skip.
+            len: u64,
+        ) -> result<u64, stream-error>;
+
+        /// Create a `pollable` which will resolve once either the specified stream
+        /// has bytes available to read or the other end of the stream has been
+        /// closed.
+        /// The created `pollable` is a child resource of the `input-stream`.
+        /// Implementations may trap if the `input-stream` is dropped before
+        /// all derived `pollable`s created with this function are dropped.
+        subscribe: func() -> pollable;
+    }
+
+
+    /// An output bytestream.
+    ///
+    /// `output-stream`s are *non-blocking* to the extent practical on
+    /// underlying platforms. Except where specified otherwise, I/O operations also
+    /// always return promptly, after the number of bytes that can be written
+    /// promptly, which could even be zero. To wait for the stream to be ready to
+    /// accept data, the `subscribe` function to obtain a `pollable` which can be
+    /// polled for using `wasi:io/poll`.
+    resource output-stream {
+        /// Check readiness for writing. This function never blocks.
+        ///
+        /// Returns the number of bytes permitted for the next call to `write`,
+        /// or an error. Calling `write` with more bytes than this function has
+        /// permitted will trap.
+        ///
+        /// When this function returns 0 bytes, the `subscribe` pollable will
+        /// become ready when this function will report at least 1 byte, or an
+        /// error.
+        check-write: func() -> result<u64, stream-error>;
+
+        /// Perform a write. This function never blocks.
+        ///
+        /// Precondition: check-write gave permit of Ok(n) and contents has a
+        /// length of less than or equal to n. Otherwise, this function will trap.
+        ///
+        /// returns Err(closed) without writing if the stream has closed since
+        /// the last call to check-write provided a permit.
+        write: func(
+            contents: list<u8>
+        ) -> result<_, stream-error>;
+
+        /// Perform a write of up to 4096 bytes, and then flush the stream. Block
+        /// until all of these operations are complete, or an error occurs.
+        ///
+        /// This is a convenience wrapper around the use of `check-write`,
+        /// `subscribe`, `write`, and `flush`, and is implemented with the
+        /// following pseudo-code:
+        ///
+        /// ```text
+        /// let pollable = this.subscribe();
+        /// while !contents.is_empty() {
+        ///     // Wait for the stream to become writable
+        ///     poll-one(pollable);
+        ///     let Ok(n) = this.check-write(); // eliding error handling
+        ///     let len = min(n, contents.len());
+        ///     let (chunk, rest) = contents.split_at(len);
+        ///     this.write(chunk  );            // eliding error handling
+        ///     contents = rest;
+        /// }
+        /// this.flush();
+        /// // Wait for completion of `flush`
+        /// poll-one(pollable);
+        /// // Check for any errors that arose during `flush`
+        /// let _ = this.check-write();         // eliding error handling
+        /// ```
+        blocking-write-and-flush: func(
+            contents: list<u8>
+        ) -> result<_, stream-error>;
+
+        /// Request to flush buffered output. This function never blocks.
+        ///
+        /// This tells the output-stream that the caller intends any buffered
+        /// output to be flushed. the output which is expected to be flushed
+        /// is all that has been passed to `write` prior to this call.
+        ///
+        /// Upon calling this function, the `output-stream` will not accept any
+        /// writes (`check-write` will return `ok(0)`) until the flush has
+        /// completed. The `subscribe` pollable will become ready when the
+        /// flush has completed and the stream can accept more writes.
+        flush: func() -> result<_, stream-error>;
+
+        /// Request to flush buffered output, and block until flush completes
+        /// and stream is ready for writing again.
+        blocking-flush: func() -> result<_, stream-error>;
+
+        /// Create a `pollable` which will resolve once the output-stream
+        /// is ready for more writing, or an error has occured. When this
+        /// pollable is ready, `check-write` will return `ok(n)` with n>0, or an
+        /// error.
+        ///
+        /// If the stream is closed, this pollable is always ready immediately.
+        ///
+        /// The created `pollable` is a child resource of the `output-stream`.
+        /// Implementations may trap if the `output-stream` is dropped before
+        /// all derived `pollable`s created with this function are dropped.
+        subscribe: func() -> pollable;
+
+        /// Write zeroes to a stream.
+        ///
+        /// this should be used precisely like `write` with the exact same
+        /// preconditions (must use check-write first), but instead of
+        /// passing a list of bytes, you simply pass the number of zero-bytes
+        /// that should be written.
+        write-zeroes: func(
+            /// The number of zero-bytes to write
+            len: u64
+        ) -> result<_, stream-error>;
+
+        /// Perform a write of up to 4096 zeroes, and then flush the stream.
+        /// Block until all of these operations are complete, or an error
+        /// occurs.
+        ///
+        /// This is a convenience wrapper around the use of `check-write`,
+        /// `subscribe`, `write-zeroes`, and `flush`, and is implemented with
+        /// the following pseudo-code:
+        ///
+        /// ```text
+        /// let pollable = this.subscribe();
+        /// while num_zeroes != 0 {
+        ///     // Wait for the stream to become writable
+        ///     poll-one(pollable);
+        ///     let Ok(n) = this.check-write(); // eliding error handling
+        ///     let len = min(n, num_zeroes);
+        ///     this.write-zeroes(len);         // eliding error handling
+        ///     num_zeroes -= len;
+        /// }
+        /// this.flush();
+        /// // Wait for completion of `flush`
+        /// poll-one(pollable);
+        /// // Check for any errors that arose during `flush`
+        /// let _ = this.check-write();         // eliding error handling
+        /// ```
+        blocking-write-zeroes-and-flush: func(
+            /// The number of zero-bytes to write
+            len: u64
+        ) -> result<_, stream-error>;
+
+        /// Read from one stream and write to another.
+        ///
+        /// This function returns the number of bytes transferred; it may be less
+        /// than `len`.
+        ///
+        /// Unlike other I/O functions, this function blocks until all the data
+        /// read from the input stream has been written to the output stream.
+        splice: func(
+            /// The stream to read from
+            src: input-stream,
+            /// The number of bytes to splice
+            len: u64,
+        ) -> result<u64, stream-error>;
+
+        /// Read from one stream and write to another, with blocking.
+        ///
+        /// This is similar to `splice`, except that it blocks until at least
+        /// one byte can be read.
+        blocking-splice: func(
+            /// The stream to read from
+            src: input-stream,
+            /// The number of bytes to splice
+            len: u64,
+        ) -> result<u64, stream-error>;
+
+        /// Forward the entire contents of an input stream to an output stream.
+        ///
+        /// This function repeatedly reads from the input stream and writes
+        /// the data to the output stream, until the end of the input stream
+        /// is reached, or an error is encountered.
+        ///
+        /// Unlike other I/O functions, this function blocks until the end
+        /// of the input stream is seen and all the data has been written to
+        /// the output stream.
+        ///
+        /// This function returns the number of bytes transferred, and the status of
+        /// the output stream.
+        forward: func(
+            /// The stream to read from
+            src: input-stream
+        ) -> result<u64, stream-error>;
+    }
+}
diff --git a/wasm-wasi-http-example/wit/deps/io/world.wit b/wasm-wasi-http-example/wit/deps/io/world.wit
new file mode 100644
index 00000000..3627c9d6
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/io/world.wit
@@ -0,0 +1,6 @@
+package wasi:io@0.2.0-rc-2023-10-18;
+
+world imports {
+    import streams;
+    import poll;
+}
diff --git a/wasm-wasi-http-example/wit/deps/logging/logging.wit b/wasm-wasi-http-example/wit/deps/logging/logging.wit
new file mode 100644
index 00000000..b897a5ae
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/logging/logging.wit
@@ -0,0 +1,37 @@
+package wasi:logging@0.2.0-rc-2023-10-18;
+
+/// WASI Logging is a logging API intended to let users emit log messages with
+/// simple priority levels and context values.
+interface logging {
+    /// A log level, describing a kind of message.
+    enum level {
+       /// Describes messages about the values of variables and the flow of
+       /// control within a program.
+       trace,
+
+       /// Describes messages likely to be of interest to someone debugging a
+       /// program.
+       debug,
+
+       /// Describes messages likely to be of interest to someone monitoring a
+       /// program.
+       info,
+
+       /// Describes messages indicating hazardous situations.
+       warn,
+
+       /// Describes messages indicating serious errors.
+       error,
+
+       /// Describes messages indicating fatal errors.
+       critical,
+    }
+
+    /// Emit a log message.
+    ///
+    /// A log message has a `level` describing what kind of message is being
+    /// sent, a context, which is an uninterpreted string meant to help
+    /// consumers group similar messages, and a string containing the message
+    /// text.
+    log: func(level: level, context: string, message: string);
+}
diff --git a/wasm-wasi-http-example/wit/deps/logging/world.wit b/wasm-wasi-http-example/wit/deps/logging/world.wit
new file mode 100644
index 00000000..a0fb255c
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/logging/world.wit
@@ -0,0 +1,5 @@
+package wasi:logging@0.2.0-rc-2023-10-18;
+
+world imports {
+    import logging;
+}
diff --git a/wasm-wasi-http-example/wit/deps/random/insecure-seed.wit b/wasm-wasi-http-example/wit/deps/random/insecure-seed.wit
new file mode 100644
index 00000000..139aed15
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/random/insecure-seed.wit
@@ -0,0 +1,24 @@
+/// The insecure-seed interface for seeding hash-map DoS resistance.
+///
+/// It is intended to be portable at least between Unix-family platforms and
+/// Windows.
+interface insecure-seed {
+    /// Return a 128-bit value that may contain a pseudo-random value.
+    ///
+    /// The returned value is not required to be computed from a CSPRNG, and may
+    /// even be entirely deterministic. Host implementations are encouraged to
+    /// provide pseudo-random values to any program exposed to
+    /// attacker-controlled content, to enable DoS protection built into many
+    /// languages' hash-map implementations.
+    ///
+    /// This function is intended to only be called once, by a source language
+    /// to initialize Denial Of Service (DoS) protection in its hash-map
+    /// implementation.
+    ///
+    /// # Expected future evolution
+    ///
+    /// This will likely be changed to a value import, to prevent it from being
+    /// called multiple times and potentially used for purposes other than DoS
+    /// protection.
+    insecure-seed: func() -> tuple<u64, u64>;
+}
diff --git a/wasm-wasi-http-example/wit/deps/random/insecure.wit b/wasm-wasi-http-example/wit/deps/random/insecure.wit
new file mode 100644
index 00000000..2ffd223c
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/random/insecure.wit
@@ -0,0 +1,21 @@
+/// The insecure interface for insecure pseudo-random numbers.
+///
+/// It is intended to be portable at least between Unix-family platforms and
+/// Windows.
+interface insecure {
+    /// Return `len` insecure pseudo-random bytes.
+    ///
+    /// This function is not cryptographically secure. Do not use it for
+    /// anything related to security.
+    ///
+    /// There are no requirements on the values of the returned bytes, however
+    /// implementations are encouraged to return evenly distributed values with
+    /// a long period.
+    get-insecure-random-bytes: func(len: u64) -> list<u8>;
+
+    /// Return an insecure pseudo-random `u64` value.
+    ///
+    /// This function returns the same type of pseudo-random data as
+    /// `get-insecure-random-bytes`, represented as a `u64`.
+    get-insecure-random-u64: func() -> u64;
+}
diff --git a/wasm-wasi-http-example/wit/deps/random/random.wit b/wasm-wasi-http-example/wit/deps/random/random.wit
new file mode 100644
index 00000000..2c3c6a85
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/random/random.wit
@@ -0,0 +1,25 @@
+/// WASI Random is a random data API.
+///
+/// It is intended to be portable at least between Unix-family platforms and
+/// Windows.
+interface random {
+    /// Return `len` cryptographically-secure random or pseudo-random bytes.
+    ///
+    /// This function must produce data at least as cryptographically secure and
+    /// fast as an adequately seeded cryptographically-secure pseudo-random
+    /// number generator (CSPRNG). It must not block, from the perspective of
+    /// the calling program, under any circumstances, including on the first
+    /// request and on requests for numbers of bytes. The returned data must
+    /// always be unpredictable.
+    ///
+    /// This function must always return fresh data. Deterministic environments
+    /// must omit this function, rather than implementing it with deterministic
+    /// data.
+    get-random-bytes: func(len: u64) -> list<u8>;
+
+    /// Return a cryptographically-secure random or pseudo-random `u64` value.
+    ///
+    /// This function returns the same type of data as `get-random-bytes`,
+    /// represented as a `u64`.
+    get-random-u64: func() -> u64;
+}
diff --git a/wasm-wasi-http-example/wit/deps/random/world.wit b/wasm-wasi-http-example/wit/deps/random/world.wit
new file mode 100644
index 00000000..dcbff938
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/random/world.wit
@@ -0,0 +1,7 @@
+package wasi:random@0.2.0-rc-2023-10-18;
+
+world imports {
+    import random;
+    import insecure;
+    import insecure-seed;
+}
diff --git a/wasm-wasi-http-example/wit/deps/sockets/instance-network.wit b/wasm-wasi-http-example/wit/deps/sockets/instance-network.wit
new file mode 100644
index 00000000..14e4479e
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/sockets/instance-network.wit
@@ -0,0 +1,9 @@
+
+/// This interface provides a value-export of the default network handle..
+interface instance-network {
+	use network.{network};
+
+	/// Get a handle to the default network.
+	instance-network: func() -> network;
+
+}
diff --git a/wasm-wasi-http-example/wit/deps/sockets/ip-name-lookup.wit b/wasm-wasi-http-example/wit/deps/sockets/ip-name-lookup.wit
new file mode 100644
index 00000000..f2dab32f
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/sockets/ip-name-lookup.wit
@@ -0,0 +1,61 @@
+
+interface ip-name-lookup {
+	use wasi:io/poll@0.2.0-rc-2023-10-18.{pollable};
+	use network.{network, error-code, ip-address, ip-address-family};
+
+
+	/// Resolve an internet host name to a list of IP addresses.
+	///
+	/// See the wasi-socket proposal README.md for a comparison with getaddrinfo.
+	///
+	/// # Parameters
+	/// - `name`: The name to look up. IP addresses are not allowed. Unicode domain names are automatically converted
+	///     to ASCII using IDNA encoding.
+	/// - `address-family`: If provided, limit the results to addresses of this specific address family.
+	/// - `include-unavailable`: When set to true, this function will also return addresses of which the runtime
+	///   thinks (or knows) can't be connected to at the moment. For example, this will return IPv6 addresses on
+	///   systems without an active IPv6 interface. Notes:
+	///     - Even when no public IPv6 interfaces are present or active, names like "localhost" can still resolve to an IPv6 address.
+	///     - Whatever is "available" or "unavailable" is volatile and can change everytime a network cable is unplugged.
+	///
+	/// This function never blocks. It either immediately fails or immediately returns successfully with a `resolve-address-stream`
+	/// that can be used to (asynchronously) fetch the results.
+	///
+	/// At the moment, the stream never completes successfully with 0 items. Ie. the first call
+	/// to `resolve-next-address` never returns `ok(none)`. This may change in the future.
+	///
+	/// # Typical errors
+	/// - `invalid-argument`:     `name` is a syntactically invalid domain name.
+	/// - `invalid-argument`:     `name` is an IP address.
+	/// - `not-supported`:        The specified `address-family` is not supported. (EAI_FAMILY)
+	///
+	/// # References:
+	/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getaddrinfo.html>
+	/// - <https://man7.org/linux/man-pages/man3/getaddrinfo.3.html>
+	/// - <https://learn.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-getaddrinfo>
+	/// - <https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&sektion=3>
+	resolve-addresses: func(network: borrow<network>, name: string, address-family: option<ip-address-family>, include-unavailable: bool) -> result<resolve-address-stream, error-code>;
+
+	resource resolve-address-stream {
+		/// Returns the next address from the resolver.
+		///
+		/// This function should be called multiple times. On each call, it will
+		/// return the next address in connection order preference. If all
+		/// addresses have been exhausted, this function returns `none`.
+		///
+		/// This function never returns IPv4-mapped IPv6 addresses.
+		///
+		/// # Typical errors
+		/// - `name-unresolvable`:          Name does not exist or has no suitable associated IP addresses. (EAI_NONAME, EAI_NODATA, EAI_ADDRFAMILY)
+		/// - `temporary-resolver-failure`: A temporary failure in name resolution occurred. (EAI_AGAIN)
+		/// - `permanent-resolver-failure`: A permanent failure in name resolution occurred. (EAI_FAIL)
+		/// - `would-block`:                A result is not available yet. (EWOULDBLOCK, EAGAIN)
+		resolve-next-address: func() -> result<option<ip-address>, error-code>;
+
+		/// Create a `pollable` which will resolve once the stream is ready for I/O.
+		///
+		/// Note: this function is here for WASI Preview2 only.
+		/// It's planned to be removed when `future` is natively supported in Preview3.
+		subscribe: func() -> pollable;
+	}
+}
diff --git a/wasm-wasi-http-example/wit/deps/sockets/network.wit b/wasm-wasi-http-example/wit/deps/sockets/network.wit
new file mode 100644
index 00000000..fc516047
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/sockets/network.wit
@@ -0,0 +1,146 @@
+
+interface network {
+	/// An opaque resource that represents access to (a subset of) the network.
+	/// This enables context-based security for networking.
+	/// There is no need for this to map 1:1 to a physical network interface.
+	resource network;
+
+	/// Error codes.
+	///
+	/// In theory, every API can return any error code.
+	/// In practice, API's typically only return the errors documented per API
+	/// combined with a couple of errors that are always possible:
+	/// - `unknown`
+	/// - `access-denied`
+	/// - `not-supported`
+	/// - `out-of-memory`
+	/// - `concurrency-conflict`
+	///
+	/// See each individual API for what the POSIX equivalents are. They sometimes differ per API.
+	enum error-code {
+		// ### GENERAL ERRORS ###
+
+		/// Unknown error
+		unknown,
+
+		/// Access denied.
+		///
+		/// POSIX equivalent: EACCES, EPERM
+		access-denied,
+
+		/// The operation is not supported.
+		///
+		/// POSIX equivalent: EOPNOTSUPP
+		not-supported,
+
+		/// One of the arguments is invalid.
+		///
+		/// POSIX equivalent: EINVAL
+		invalid-argument,
+
+		/// Not enough memory to complete the operation.
+		///
+		/// POSIX equivalent: ENOMEM, ENOBUFS, EAI_MEMORY
+		out-of-memory,
+
+		/// The operation timed out before it could finish completely.
+		timeout,
+
+		/// This operation is incompatible with another asynchronous operation that is already in progress.
+		///
+		/// POSIX equivalent: EALREADY
+		concurrency-conflict,
+
+		/// Trying to finish an asynchronous operation that:
+		/// - has not been started yet, or:
+		/// - was already finished by a previous `finish-*` call.
+		///
+		/// Note: this is scheduled to be removed when `future`s are natively supported.
+		not-in-progress,
+
+		/// The operation has been aborted because it could not be completed immediately.
+		///
+		/// Note: this is scheduled to be removed when `future`s are natively supported.
+		would-block,
+
+
+
+		// ### TCP & UDP SOCKET ERRORS ###
+
+		/// The operation is not valid in the socket's current state.
+		invalid-state,
+
+		/// A new socket resource could not be created because of a system limit.
+		new-socket-limit,
+
+		/// A bind operation failed because the provided address is not an address that the `network` can bind to.
+		address-not-bindable,
+
+		/// A bind operation failed because the provided address is already in use or because there are no ephemeral ports available.
+		address-in-use,
+
+		/// The remote address is not reachable
+		remote-unreachable,
+
+
+		// ### TCP SOCKET ERRORS ###
+
+		/// The connection was forcefully rejected
+		connection-refused,
+
+		/// The connection was reset.
+		connection-reset,
+
+		/// A connection was aborted.
+		connection-aborted,
+
+		// ### UDP SOCKET ERRORS ###
+		datagram-too-large,
+
+
+		// ### NAME LOOKUP ERRORS ###
+
+		/// Name does not exist or has no suitable associated IP addresses.
+		name-unresolvable,
+
+		/// A temporary failure in name resolution occurred.
+		temporary-resolver-failure,
+
+		/// A permanent failure in name resolution occurred.
+		permanent-resolver-failure,
+	}
+
+	enum ip-address-family {
+		/// Similar to `AF_INET` in POSIX.
+		ipv4,
+
+		/// Similar to `AF_INET6` in POSIX.
+		ipv6,
+	}
+
+	type ipv4-address = tuple<u8, u8, u8, u8>;
+	type ipv6-address = tuple<u16, u16, u16, u16, u16, u16, u16, u16>;
+
+	variant ip-address {
+		ipv4(ipv4-address),
+		ipv6(ipv6-address),
+	}
+
+	record ipv4-socket-address {
+		port: u16, // sin_port
+		address: ipv4-address, // sin_addr
+	}
+
+	record ipv6-socket-address {
+		port: u16, // sin6_port
+		flow-info: u32, // sin6_flowinfo
+		address: ipv6-address, // sin6_addr
+		scope-id: u32, // sin6_scope_id
+	}
+
+	variant ip-socket-address {
+		ipv4(ipv4-socket-address),
+		ipv6(ipv6-socket-address),
+	}
+
+}
diff --git a/wasm-wasi-http-example/wit/deps/sockets/tcp-create-socket.wit b/wasm-wasi-http-example/wit/deps/sockets/tcp-create-socket.wit
new file mode 100644
index 00000000..a9a33738
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/sockets/tcp-create-socket.wit
@@ -0,0 +1,26 @@
+
+interface tcp-create-socket {
+	use network.{network, error-code, ip-address-family};
+	use tcp.{tcp-socket};
+
+	/// Create a new TCP socket.
+	///
+	/// Similar to `socket(AF_INET or AF_INET6, SOCK_STREAM, IPPROTO_TCP)` in POSIX.
+	///
+	/// This function does not require a network capability handle. This is considered to be safe because
+	/// at time of creation, the socket is not bound to any `network` yet. Up to the moment `bind`/`listen`/`connect`
+	/// is called, the socket is effectively an in-memory configuration object, unable to communicate with the outside world.
+	///
+	/// All sockets are non-blocking. Use the wasi-poll interface to block on asynchronous operations.
+	///
+	/// # Typical errors
+	/// - `not-supported`:     The specified `address-family` is not supported. (EAFNOSUPPORT)
+	/// - `new-socket-limit`:  The new socket resource could not be created because of a system limit. (EMFILE, ENFILE)
+	///
+	/// # References
+	/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html>
+	/// - <https://man7.org/linux/man-pages/man2/socket.2.html>
+	/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketw>
+	/// - <https://man.freebsd.org/cgi/man.cgi?query=socket&sektion=2>
+	create-tcp-socket: func(address-family: ip-address-family) -> result<tcp-socket, error-code>;
+}
diff --git a/wasm-wasi-http-example/wit/deps/sockets/tcp.wit b/wasm-wasi-http-example/wit/deps/sockets/tcp.wit
new file mode 100644
index 00000000..448f629e
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/sockets/tcp.wit
@@ -0,0 +1,268 @@
+
+interface tcp {
+	use wasi:io/streams@0.2.0-rc-2023-10-18.{input-stream, output-stream};
+	use wasi:io/poll@0.2.0-rc-2023-10-18.{pollable};
+	use network.{network, error-code, ip-socket-address, ip-address-family};
+
+	enum shutdown-type {
+		/// Similar to `SHUT_RD` in POSIX.
+		receive,
+
+		/// Similar to `SHUT_WR` in POSIX.
+		send,
+
+		/// Similar to `SHUT_RDWR` in POSIX.
+		both,
+	}
+
+
+	/// A TCP socket handle.
+	resource tcp-socket {
+		/// Bind the socket to a specific network on the provided IP address and port.
+		///
+		/// If the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the implementation to decide which
+		/// network interface(s) to bind to.
+		/// If the TCP/UDP port is zero, the socket will be bound to a random free port.
+		///
+		/// When a socket is not explicitly bound, the first invocation to a listen or connect operation will
+		/// implicitly bind the socket.
+		///
+		/// Unlike in POSIX, this function is async. This enables interactive WASI hosts to inject permission prompts.
+		///
+		/// # Typical `start` errors
+		/// - `invalid-argument`:          The `local-address` has the wrong address family. (EAFNOSUPPORT, EFAULT on Windows)
+		/// - `invalid-argument`:          `local-address` is not a unicast address. (EINVAL)
+		/// - `invalid-argument`:          `local-address` is an IPv4-mapped IPv6 address, but the socket has `ipv6-only` enabled. (EINVAL)
+		/// - `invalid-state`:             The socket is already bound. (EINVAL)
+		///
+		/// # Typical `finish` errors
+		/// - `address-in-use`:            No ephemeral ports available. (EADDRINUSE, ENOBUFS on Windows)
+		/// - `address-in-use`:            Address is already in use. (EADDRINUSE)
+		/// - `address-not-bindable`:      `local-address` is not an address that the `network` can bind to. (EADDRNOTAVAIL)
+		/// - `not-in-progress`:           A `bind` operation is not in progress.
+		/// - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)
+		///
+		/// # References
+		/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html>
+		/// - <https://man7.org/linux/man-pages/man2/bind.2.html>
+		/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind>
+		/// - <https://man.freebsd.org/cgi/man.cgi?query=bind&sektion=2&format=html>
+		start-bind: func(network: borrow<network>, local-address: ip-socket-address) -> result<_, error-code>;
+		finish-bind: func() -> result<_, error-code>;
+
+		/// Connect to a remote endpoint.
+		///
+		/// On success:
+		/// - the socket is transitioned into the Connection state
+		/// - a pair of streams is returned that can be used to read & write to the connection
+		///
+		/// POSIX mentions:
+		/// > If connect() fails, the state of the socket is unspecified. Conforming applications should
+		/// > close the file descriptor and create a new socket before attempting to reconnect.
+		///
+		/// WASI prescribes the following behavior:
+		/// - If `connect` fails because an input/state validation error, the socket should remain usable.
+		/// - If a connection was actually attempted but failed, the socket should become unusable for further network communication.
+		///   Besides `drop`, any method after such a failure may return an error.
+		///
+		/// # Typical `start` errors
+		/// - `invalid-argument`:          The `remote-address` has the wrong address family. (EAFNOSUPPORT)
+		/// - `invalid-argument`:          `remote-address` is not a unicast address. (EINVAL, ENETUNREACH on Linux, EAFNOSUPPORT on MacOS)
+		/// - `invalid-argument`:          `remote-address` is an IPv4-mapped IPv6 address, but the socket has `ipv6-only` enabled. (EINVAL, EADDRNOTAVAIL on Illumos)
+		/// - `invalid-argument`:          `remote-address` is a non-IPv4-mapped IPv6 address, but the socket was bound to a specific IPv4-mapped IPv6 address. (or vice versa)
+		/// - `invalid-argument`:          The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EADDRNOTAVAIL on Windows)
+		/// - `invalid-argument`:          The port in `remote-address` is set to 0. (EADDRNOTAVAIL on Windows)
+		/// - `invalid-argument`:          The socket is already attached to a different network. The `network` passed to `connect` must be identical to the one passed to `bind`.
+		/// - `invalid-state`:             The socket is already in the Connection state. (EISCONN)
+		/// - `invalid-state`:             The socket is already in the Listener state. (EOPNOTSUPP, EINVAL on Windows)
+		///
+		/// # Typical `finish` errors
+		/// - `timeout`:                   Connection timed out. (ETIMEDOUT)
+		/// - `connection-refused`:        The connection was forcefully rejected. (ECONNREFUSED)
+		/// - `connection-reset`:          The connection was reset. (ECONNRESET)
+		/// - `connection-aborted`:        The connection was aborted. (ECONNABORTED)
+		/// - `remote-unreachable`:        The remote address is not reachable. (EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN)
+		/// - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE, EADDRNOTAVAIL on Linux, EAGAIN on BSD)
+		/// - `not-in-progress`:           A `connect` operation is not in progress.
+		/// - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)
+		///
+		/// # References
+		/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
+		/// - <https://man7.org/linux/man-pages/man2/connect.2.html>
+		/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
+		/// - <https://man.freebsd.org/cgi/man.cgi?connect>
+		start-connect: func(network: borrow<network>, remote-address: ip-socket-address) -> result<_, error-code>;
+		finish-connect: func() -> result<tuple<input-stream, output-stream>, error-code>;
+
+		/// Start listening for new connections.
+		///
+		/// Transitions the socket into the Listener state.
+		///
+		/// Unlike POSIX:
+		/// - this function is async. This enables interactive WASI hosts to inject permission prompts.
+		/// - the socket must already be explicitly bound.
+		///
+		/// # Typical `start` errors
+		/// - `invalid-state`:             The socket is not bound to any local address. (EDESTADDRREQ)
+		/// - `invalid-state`:             The socket is already in the Connection state. (EISCONN, EINVAL on BSD)
+		/// - `invalid-state`:             The socket is already in the Listener state.
+		///
+		/// # Typical `finish` errors
+		/// - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE)
+		/// - `not-in-progress`:           A `listen` operation is not in progress.
+		/// - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)
+		///
+		/// # References
+		/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/listen.html>
+		/// - <https://man7.org/linux/man-pages/man2/listen.2.html>
+		/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-listen>
+		/// - <https://man.freebsd.org/cgi/man.cgi?query=listen&sektion=2>
+		start-listen: func() -> result<_, error-code>;
+		finish-listen: func() -> result<_, error-code>;
+
+		/// Accept a new client socket.
+		///
+		/// The returned socket is bound and in the Connection state. The following properties are inherited from the listener socket:
+		/// - `address-family`
+		/// - `ipv6-only`
+		/// - `keep-alive`
+		/// - `no-delay`
+		/// - `unicast-hop-limit`
+		/// - `receive-buffer-size`
+		/// - `send-buffer-size`
+		///
+		/// On success, this function returns the newly accepted client socket along with
+		/// a pair of streams that can be used to read & write to the connection.
+		///
+		/// # Typical errors
+		/// - `invalid-state`:      Socket is not in the Listener state. (EINVAL)
+		/// - `would-block`:        No pending connections at the moment. (EWOULDBLOCK, EAGAIN)
+		/// - `connection-aborted`: An incoming connection was pending, but was terminated by the client before this listener could accept it. (ECONNABORTED)
+		/// - `new-socket-limit`:   The new socket resource could not be created because of a system limit. (EMFILE, ENFILE)
+		///
+		/// # References
+		/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/accept.html>
+		/// - <https://man7.org/linux/man-pages/man2/accept.2.html>
+		/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-accept>
+		/// - <https://man.freebsd.org/cgi/man.cgi?query=accept&sektion=2>
+		accept: func() -> result<tuple<tcp-socket, input-stream, output-stream>, error-code>;
+
+		/// Get the bound local address.
+		///
+		/// POSIX mentions:
+		/// > If the socket has not been bound to a local name, the value
+		/// > stored in the object pointed to by `address` is unspecified.
+		///
+		/// WASI is stricter and requires `local-address` to return `invalid-state` when the socket hasn't been bound yet.
+		///
+		/// # Typical errors
+		/// - `invalid-state`: The socket is not bound to any local address.
+		///
+		/// # References
+		/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html>
+		/// - <https://man7.org/linux/man-pages/man2/getsockname.2.html>
+		/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname>
+		/// - <https://man.freebsd.org/cgi/man.cgi?getsockname>
+		local-address: func() -> result<ip-socket-address, error-code>;
+
+		/// Get the remote address.
+		///
+		/// # Typical errors
+		/// - `invalid-state`: The socket is not connected to a remote address. (ENOTCONN)
+		///
+		/// # References
+		/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html>
+		/// - <https://man7.org/linux/man-pages/man2/getpeername.2.html>
+		/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername>
+		/// - <https://man.freebsd.org/cgi/man.cgi?query=getpeername&sektion=2&n=1>
+		remote-address: func() -> result<ip-socket-address, error-code>;
+
+		/// Whether this is a IPv4 or IPv6 socket.
+		///
+		/// Equivalent to the SO_DOMAIN socket option.
+		address-family: func() -> ip-address-family;
+
+		/// Whether IPv4 compatibility (dual-stack) mode is disabled or not.
+		///
+		/// Equivalent to the IPV6_V6ONLY socket option.
+		///
+		/// # Typical errors
+		/// - `invalid-state`:        (set) The socket is already bound.
+		/// - `not-supported`:        (get/set) `this` socket is an IPv4 socket.
+		/// - `not-supported`:        (set) Host does not support dual-stack sockets. (Implementations are not required to.)
+		ipv6-only: func() -> result<bool, error-code>;
+		set-ipv6-only: func(value: bool) -> result<_, error-code>;
+
+		/// Hints the desired listen queue size. Implementations are free to ignore this.
+		///
+		/// # Typical errors
+		/// - `not-supported`:        (set) The platform does not support changing the backlog size after the initial listen.
+		/// - `invalid-state`:        (set) The socket is already in the Connection state.
+		set-listen-backlog-size: func(value: u64) -> result<_, error-code>;
+
+		/// Equivalent to the SO_KEEPALIVE socket option.
+		keep-alive: func() -> result<bool, error-code>;
+		set-keep-alive: func(value: bool) -> result<_, error-code>;
+
+		/// Equivalent to the TCP_NODELAY socket option.
+		///
+		/// The default value is `false`.
+		no-delay: func() -> result<bool, error-code>;
+		set-no-delay: func(value: bool) -> result<_, error-code>;
+
+		/// Equivalent to the IP_TTL & IPV6_UNICAST_HOPS socket options.
+		///
+		/// # Typical errors
+		/// - `invalid-argument`:     (set) The TTL value must be 1 or higher.
+		/// - `invalid-state`:        (set) The socket is already in the Connection state.
+		/// - `invalid-state`:        (set) The socket is already in the Listener state.
+		unicast-hop-limit: func() -> result<u8, error-code>;
+		set-unicast-hop-limit: func(value: u8) -> result<_, error-code>;
+
+		/// The kernel buffer space reserved for sends/receives on this socket.
+		///
+		/// Note #1: an implementation may choose to cap or round the buffer size when setting the value.
+		/// 	In other words, after setting a value, reading the same setting back may return a different value.
+		///
+		/// Note #2: there is not necessarily a direct relationship between the kernel buffer size and the bytes of
+		/// 	actual data to be sent/received by the application, because the kernel might also use the buffer space
+		/// 	for internal metadata structures.
+		///
+		/// Equivalent to the SO_RCVBUF and SO_SNDBUF socket options.
+		///
+		/// # Typical errors
+		/// - `invalid-state`:        (set) The socket is already in the Connection state.
+		/// - `invalid-state`:        (set) The socket is already in the Listener state.
+		receive-buffer-size: func() -> result<u64, error-code>;
+		set-receive-buffer-size: func(value: u64) -> result<_, error-code>;
+		send-buffer-size: func() -> result<u64, error-code>;
+		set-send-buffer-size: func(value: u64) -> result<_, error-code>;
+
+		/// Create a `pollable` which will resolve once the socket is ready for I/O.
+		///
+		/// Note: this function is here for WASI Preview2 only.
+		/// It's planned to be removed when `future` is natively supported in Preview3.
+		subscribe: func() -> pollable;
+
+		/// Initiate a graceful shutdown.
+		///
+		/// - receive: the socket is not expecting to receive any more data from the peer. All subsequent read
+		///   operations on the `input-stream` associated with this socket will return an End Of Stream indication.
+		///   Any data still in the receive queue at time of calling `shutdown` will be discarded.
+		/// - send: the socket is not expecting to send any more data to the peer. All subsequent write
+		///   operations on the `output-stream` associated with this socket will return an error.
+		/// - both: same effect as receive & send combined.
+		///
+		/// The shutdown function does not close (drop) the socket.
+		///
+		/// # Typical errors
+		/// - `invalid-state`: The socket is not in the Connection state. (ENOTCONN)
+		///
+		/// # References
+		/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/shutdown.html>
+		/// - <https://man7.org/linux/man-pages/man2/shutdown.2.html>
+		/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-shutdown>
+		/// - <https://man.freebsd.org/cgi/man.cgi?query=shutdown&sektion=2>
+		shutdown: func(shutdown-type: shutdown-type) -> result<_, error-code>;
+	}
+}
diff --git a/wasm-wasi-http-example/wit/deps/sockets/udp-create-socket.wit b/wasm-wasi-http-example/wit/deps/sockets/udp-create-socket.wit
new file mode 100644
index 00000000..e026359f
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/sockets/udp-create-socket.wit
@@ -0,0 +1,26 @@
+
+interface udp-create-socket {
+	use network.{network, error-code, ip-address-family};
+	use udp.{udp-socket};
+
+	/// Create a new UDP socket.
+	///
+	/// Similar to `socket(AF_INET or AF_INET6, SOCK_DGRAM, IPPROTO_UDP)` in POSIX.
+	///
+	/// This function does not require a network capability handle. This is considered to be safe because
+	/// at time of creation, the socket is not bound to any `network` yet. Up to the moment `bind`/`connect` is called,
+	/// the socket is effectively an in-memory configuration object, unable to communicate with the outside world.
+	///
+	/// All sockets are non-blocking. Use the wasi-poll interface to block on asynchronous operations.
+	///
+	/// # Typical errors
+	/// - `not-supported`:     The specified `address-family` is not supported. (EAFNOSUPPORT)
+	/// - `new-socket-limit`:  The new socket resource could not be created because of a system limit. (EMFILE, ENFILE)
+	///
+	/// # References:
+	/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html>
+	/// - <https://man7.org/linux/man-pages/man2/socket.2.html>
+	/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketw>
+	/// - <https://man.freebsd.org/cgi/man.cgi?query=socket&sektion=2>
+	create-udp-socket: func(address-family: ip-address-family) -> result<udp-socket, error-code>;
+}
diff --git a/wasm-wasi-http-example/wit/deps/sockets/udp.wit b/wasm-wasi-http-example/wit/deps/sockets/udp.wit
new file mode 100644
index 00000000..91a8c6c4
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/sockets/udp.wit
@@ -0,0 +1,213 @@
+
+interface udp {
+	use wasi:io/poll@0.2.0-rc-2023-10-18.{pollable};
+	use network.{network, error-code, ip-socket-address, ip-address-family};
+
+
+	record datagram {
+		data: list<u8>, // Theoretical max size: ~64 KiB. In practice, typically less than 1500 bytes.
+		remote-address: ip-socket-address,
+
+		/// Possible future additions:
+		/// local-address: ip-socket-address, // IP_PKTINFO / IP_RECVDSTADDR / IPV6_PKTINFO
+		/// local-interface: u32, // IP_PKTINFO / IP_RECVIF
+		/// ttl: u8, // IP_RECVTTL
+		/// dscp: u6, // IP_RECVTOS
+		/// ecn: u2, // IP_RECVTOS
+	}
+
+
+
+	/// A UDP socket handle.
+	resource udp-socket {
+		/// Bind the socket to a specific network on the provided IP address and port.
+		///
+		/// If the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the implementation to decide which
+		/// network interface(s) to bind to.
+		/// If the TCP/UDP port is zero, the socket will be bound to a random free port.
+		///
+		/// When a socket is not explicitly bound, the first invocation to connect will implicitly bind the socket.
+		///
+		/// Unlike in POSIX, this function is async. This enables interactive WASI hosts to inject permission prompts.
+		///
+		/// # Typical `start` errors
+		/// - `invalid-argument`:          The `local-address` has the wrong address family. (EAFNOSUPPORT, EFAULT on Windows)
+		/// - `invalid-state`:             The socket is already bound. (EINVAL)
+		///
+		/// # Typical `finish` errors
+		/// - `address-in-use`:            No ephemeral ports available. (EADDRINUSE, ENOBUFS on Windows)
+		/// - `address-in-use`:            Address is already in use. (EADDRINUSE)
+		/// - `address-not-bindable`:      `local-address` is not an address that the `network` can bind to. (EADDRNOTAVAIL)
+		/// - `not-in-progress`:           A `bind` operation is not in progress.
+		/// - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)
+		///
+		/// # References
+		/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html>
+		/// - <https://man7.org/linux/man-pages/man2/bind.2.html>
+		/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind>
+		/// - <https://man.freebsd.org/cgi/man.cgi?query=bind&sektion=2&format=html>
+		start-bind: func(network: borrow<network>, local-address: ip-socket-address) -> result<_, error-code>;
+		finish-bind: func() -> result<_, error-code>;
+
+		/// Set the destination address.
+		///
+		/// The local-address is updated based on the best network path to `remote-address`.
+		///
+		/// When a destination address is set:
+		/// - all receive operations will only return datagrams sent from the provided `remote-address`.
+		/// - the `send` function can only be used to send to this destination.
+		///
+		/// Note that this function does not generate any network traffic and the peer is not aware of this "connection".
+		///
+		/// Unlike in POSIX, this function is async. This enables interactive WASI hosts to inject permission prompts.
+		///
+		/// # Typical `start` errors
+		/// - `invalid-argument`:          The `remote-address` has the wrong address family. (EAFNOSUPPORT)
+		/// - `invalid-argument`:          `remote-address` is a non-IPv4-mapped IPv6 address, but the socket was bound to a specific IPv4-mapped IPv6 address. (or vice versa)
+		/// - `invalid-argument`:          The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EDESTADDRREQ, EADDRNOTAVAIL)
+		/// - `invalid-argument`:          The port in `remote-address` is set to 0. (EDESTADDRREQ, EADDRNOTAVAIL)
+		/// - `invalid-argument`:          The socket is already bound to a different network. The `network` passed to `connect` must be identical to the one passed to `bind`.
+		///
+		/// # Typical `finish` errors
+		/// - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE, EADDRNOTAVAIL on Linux, EAGAIN on BSD)
+		/// - `not-in-progress`:           A `connect` operation is not in progress.
+		/// - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK, EAGAIN)
+		///
+		/// # References
+		/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
+		/// - <https://man7.org/linux/man-pages/man2/connect.2.html>
+		/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
+		/// - <https://man.freebsd.org/cgi/man.cgi?connect>
+		start-connect: func(network: borrow<network>, remote-address: ip-socket-address) -> result<_, error-code>;
+		finish-connect: func() -> result<_, error-code>;
+
+		/// Receive messages on the socket.
+		///
+		/// This function attempts to receive up to `max-results` datagrams on the socket without blocking.
+		/// The returned list may contain fewer elements than requested, but never more.
+		/// If `max-results` is 0, this function returns successfully with an empty list.
+		///
+		/// # Typical errors
+		/// - `invalid-state`:      The socket is not bound to any local address. (EINVAL)
+		/// - `remote-unreachable`: The remote address is not reachable. (ECONNREFUSED, ECONNRESET, ENETRESET on Windows, EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN)
+		/// - `would-block`:        There is no pending data available to be read at the moment. (EWOULDBLOCK, EAGAIN)
+		///
+		/// # References
+		/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvfrom.html>
+		/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvmsg.html>
+		/// - <https://man7.org/linux/man-pages/man2/recv.2.html>
+		/// - <https://man7.org/linux/man-pages/man2/recvmmsg.2.html>
+		/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recv>
+		/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recvfrom>
+		/// - <https://learn.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms741687(v=vs.85)>
+		/// - <https://man.freebsd.org/cgi/man.cgi?query=recv&sektion=2>
+		receive: func(max-results: u64) -> result<list<datagram>, error-code>;
+
+		/// Send messages on the socket.
+		///
+		/// This function attempts to send all provided `datagrams` on the socket without blocking and
+		/// returns how many messages were actually sent (or queued for sending).
+		///
+		/// This function semantically behaves the same as iterating the `datagrams` list and sequentially
+		/// sending each individual datagram until either the end of the list has been reached or the first error occurred.
+		/// If at least one datagram has been sent successfully, this function never returns an error.
+		///
+		/// If the input list is empty, the function returns `ok(0)`.
+		///
+		/// The remote address option is required. To send a message to the "connected" peer,
+		/// call `remote-address` to get their address.
+		///
+		/// # Typical errors
+		/// - `invalid-argument`:        The `remote-address` has the wrong address family. (EAFNOSUPPORT)
+		/// - `invalid-argument`:        `remote-address` is a non-IPv4-mapped IPv6 address, but the socket was bound to a specific IPv4-mapped IPv6 address. (or vice versa)
+		/// - `invalid-argument`:        The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EDESTADDRREQ, EADDRNOTAVAIL)
+		/// - `invalid-argument`:        The port in `remote-address` is set to 0. (EDESTADDRREQ, EADDRNOTAVAIL)
+		/// - `invalid-argument`:        The socket is in "connected" mode and the `datagram.remote-address` does not match the address passed to `connect`. (EISCONN)
+		/// - `invalid-state`:           The socket is not bound to any local address. Unlike POSIX, this function does not perform an implicit bind.
+		/// - `remote-unreachable`:      The remote address is not reachable. (ECONNREFUSED, ECONNRESET, ENETRESET on Windows, EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN)
+		/// - `datagram-too-large`:      The datagram is too large. (EMSGSIZE)
+		/// - `would-block`:             The send buffer is currently full. (EWOULDBLOCK, EAGAIN)
+		///
+		/// # References
+		/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendto.html>
+		/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendmsg.html>
+		/// - <https://man7.org/linux/man-pages/man2/send.2.html>
+		/// - <https://man7.org/linux/man-pages/man2/sendmmsg.2.html>
+		/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-send>
+		/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-sendto>
+		/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasendmsg>
+		/// - <https://man.freebsd.org/cgi/man.cgi?query=send&sektion=2>
+		send: func(datagrams: list<datagram>) -> result<u64, error-code>;
+
+		/// Get the current bound address.
+		///
+		/// POSIX mentions:
+		/// > If the socket has not been bound to a local name, the value
+		/// > stored in the object pointed to by `address` is unspecified.
+		///
+		/// WASI is stricter and requires `local-address` to return `invalid-state` when the socket hasn't been bound yet.
+		///
+		/// # Typical errors
+		/// - `invalid-state`: The socket is not bound to any local address.
+		///
+		/// # References
+		/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html>
+		/// - <https://man7.org/linux/man-pages/man2/getsockname.2.html>
+		/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname>
+		/// - <https://man.freebsd.org/cgi/man.cgi?getsockname>
+		local-address: func() -> result<ip-socket-address, error-code>;
+
+		/// Get the address set with `connect`.
+		///
+		/// # Typical errors
+		/// - `invalid-state`: The socket is not connected to a remote address. (ENOTCONN)
+		///
+		/// # References
+		/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html>
+		/// - <https://man7.org/linux/man-pages/man2/getpeername.2.html>
+		/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername>
+		/// - <https://man.freebsd.org/cgi/man.cgi?query=getpeername&sektion=2&n=1>
+		remote-address: func() -> result<ip-socket-address, error-code>;
+
+		/// Whether this is a IPv4 or IPv6 socket.
+		///
+		/// Equivalent to the SO_DOMAIN socket option.
+		address-family: func() -> ip-address-family;
+
+		/// Whether IPv4 compatibility (dual-stack) mode is disabled or not.
+		///
+		/// Equivalent to the IPV6_V6ONLY socket option.
+		///
+		/// # Typical errors
+		/// - `not-supported`:        (get/set) `this` socket is an IPv4 socket.
+		/// - `invalid-state`:        (set) The socket is already bound.
+		/// - `not-supported`:        (set) Host does not support dual-stack sockets. (Implementations are not required to.)
+		ipv6-only: func() -> result<bool, error-code>;
+		set-ipv6-only: func(value: bool) -> result<_, error-code>;
+
+		/// Equivalent to the IP_TTL & IPV6_UNICAST_HOPS socket options.
+		unicast-hop-limit: func() -> result<u8, error-code>;
+		set-unicast-hop-limit: func(value: u8) -> result<_, error-code>;
+
+		/// The kernel buffer space reserved for sends/receives on this socket.
+		///
+		/// Note #1: an implementation may choose to cap or round the buffer size when setting the value.
+		/// 	In other words, after setting a value, reading the same setting back may return a different value.
+		///
+		/// Note #2: there is not necessarily a direct relationship between the kernel buffer size and the bytes of
+		/// 	actual data to be sent/received by the application, because the kernel might also use the buffer space
+		/// 	for internal metadata structures.
+		///
+		/// Equivalent to the SO_RCVBUF and SO_SNDBUF socket options.
+		receive-buffer-size: func() -> result<u64, error-code>;
+		set-receive-buffer-size: func(value: u64) -> result<_, error-code>;
+		send-buffer-size: func() -> result<u64, error-code>;
+		set-send-buffer-size: func(value: u64) -> result<_, error-code>;
+
+		/// Create a `pollable` which will resolve once the socket is ready for I/O.
+		///
+		/// Note: this function is here for WASI Preview2 only.
+		/// It's planned to be removed when `future` is natively supported in Preview3.
+		subscribe: func() -> pollable;
+	}
+}
diff --git a/wasm-wasi-http-example/wit/deps/sockets/world.wit b/wasm-wasi-http-example/wit/deps/sockets/world.wit
new file mode 100644
index 00000000..d16530c3
--- /dev/null
+++ b/wasm-wasi-http-example/wit/deps/sockets/world.wit
@@ -0,0 +1,11 @@
+package wasi:sockets@0.2.0-rc-2023-10-18;
+
+world imports {
+    import instance-network;
+    import network;
+    import udp;
+    import udp-create-socket;
+    import tcp;
+    import tcp-create-socket;
+    import ip-name-lookup;
+}
diff --git a/wasm-wasi-http-example/wit/main.wit b/wasm-wasi-http-example/wit/main.wit
new file mode 100644
index 00000000..f3a4e60c
--- /dev/null
+++ b/wasm-wasi-http-example/wit/main.wit
@@ -0,0 +1,33 @@
+package wasmtime:wasi;
+
+// All of the same imports available in the wasi:cli/command world, but no
+// export required:
+world preview1-adapter-reactor {
+  import wasi:clocks/wall-clock@0.2.0-rc-2023-10-18;
+  import wasi:clocks/monotonic-clock@0.2.0-rc-2023-10-18;
+  import wasi:clocks/timezone@0.2.0-rc-2023-10-18;
+  import wasi:filesystem/types@0.2.0-rc-2023-10-18;
+  import wasi:filesystem/preopens@0.2.0-rc-2023-10-18;
+  import wasi:sockets/instance-network@0.2.0-rc-2023-10-18;
+  import wasi:sockets/ip-name-lookup@0.2.0-rc-2023-10-18;
+  import wasi:sockets/network@0.2.0-rc-2023-10-18;
+  import wasi:sockets/tcp-create-socket@0.2.0-rc-2023-10-18;
+  import wasi:sockets/tcp@0.2.0-rc-2023-10-18;
+  import wasi:sockets/udp-create-socket@0.2.0-rc-2023-10-18;
+  import wasi:sockets/udp@0.2.0-rc-2023-10-18;
+  import wasi:random/random@0.2.0-rc-2023-10-18;
+  import wasi:random/insecure@0.2.0-rc-2023-10-18;
+  import wasi:random/insecure-seed@0.2.0-rc-2023-10-18;
+  import wasi:io/poll@0.2.0-rc-2023-10-18;
+  import wasi:io/streams@0.2.0-rc-2023-10-18;
+  import wasi:cli/environment@0.2.0-rc-2023-10-18;
+  import wasi:cli/exit@0.2.0-rc-2023-10-18;
+  import wasi:cli/stdin@0.2.0-rc-2023-10-18;
+  import wasi:cli/stdout@0.2.0-rc-2023-10-18;
+  import wasi:cli/stderr@0.2.0-rc-2023-10-18;
+  import wasi:cli/terminal-input@0.2.0-rc-2023-10-18;
+  import wasi:cli/terminal-output@0.2.0-rc-2023-10-18;
+  import wasi:cli/terminal-stdin@0.2.0-rc-2023-10-18;
+  import wasi:cli/terminal-stdout@0.2.0-rc-2023-10-18;
+  import wasi:cli/terminal-stderr@0.2.0-rc-2023-10-18;
+}
diff --git a/wasm-wasi-http-example/wit/test.wit b/wasm-wasi-http-example/wit/test.wit
new file mode 100644
index 00000000..3db5e082
--- /dev/null
+++ b/wasm-wasi-http-example/wit/test.wit
@@ -0,0 +1,46 @@
+// only used as part of `test-programs`
+world test-reactor {
+
+  import wasi:cli/environment@0.2.0-rc-2023-10-18;
+  import wasi:io/poll@0.2.0-rc-2023-10-18;
+  import wasi:io/streams@0.2.0-rc-2023-10-18;
+  import wasi:filesystem/types@0.2.0-rc-2023-10-18;
+  import wasi:filesystem/preopens@0.2.0-rc-2023-10-18;
+  import wasi:cli/exit@0.2.0-rc-2023-10-18;
+
+  export add-strings: func(s: list<string>) -> u32;
+  export get-strings: func() -> list<string>;
+
+  use wasi:io/streams@0.2.0-rc-2023-10-18.{output-stream};
+
+  export write-strings-to: func(o: output-stream) -> result;
+
+  use wasi:filesystem/types@0.2.0-rc-2023-10-18.{descriptor-stat};
+  export pass-an-imported-record: func(d: descriptor-stat) -> string;
+}
+
+world test-command {
+  import wasi:io/poll@0.2.0-rc-2023-10-18;
+  import wasi:io/streams@0.2.0-rc-2023-10-18;
+  import wasi:cli/environment@0.2.0-rc-2023-10-18;
+  import wasi:cli/stdin@0.2.0-rc-2023-10-18;
+  import wasi:cli/stdout@0.2.0-rc-2023-10-18;
+  import wasi:cli/stderr@0.2.0-rc-2023-10-18;
+}
+
+world test-command-with-sockets {
+  import wasi:io/poll@0.2.0-rc-2023-10-18;
+  import wasi:io/streams@0.2.0-rc-2023-10-18;
+  import wasi:cli/environment@0.2.0-rc-2023-10-18;
+  import wasi:cli/stdin@0.2.0-rc-2023-10-18;
+  import wasi:cli/stdout@0.2.0-rc-2023-10-18;
+  import wasi:cli/stderr@0.2.0-rc-2023-10-18;
+  import wasi:sockets/tcp@0.2.0-rc-2023-10-18;
+  import wasi:sockets/tcp-create-socket@0.2.0-rc-2023-10-18;
+  import wasi:sockets/udp@0.2.0-rc-2023-10-18;
+  import wasi:sockets/udp-create-socket@0.2.0-rc-2023-10-18;
+  import wasi:sockets/network@0.2.0-rc-2023-10-18;
+  import wasi:sockets/instance-network@0.2.0-rc-2023-10-18;
+  import wasi:sockets/ip-name-lookup@0.2.0-rc-2023-10-18;
+  import wasi:clocks/monotonic-clock@0.2.0-rc-2023-10-18;
+}
